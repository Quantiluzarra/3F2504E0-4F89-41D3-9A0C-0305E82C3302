<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AES-256-GCM Encryption Vault</title>
    <style>
        :root {
            --color-white: rgba(255, 255, 255, 1);
            --color-black: rgba(0, 0, 0, 1);
            --color-cream-50: rgba(252, 252, 249, 1);
            --color-cream-100: rgba(255, 255, 253, 1);
            --color-gray-200: rgba(245, 245, 245, 1);
            --color-gray-300: rgba(167, 169, 169, 1);
            --color-slate-500: rgba(98, 108, 113, 1);
            --color-slate-900: rgba(19, 52, 59, 1);
            --color-teal-300: rgba(50, 184, 198, 1);
            --color-teal-500: rgba(33, 128, 141, 1);
            --color-teal-600: rgba(29, 116, 128, 1);
            --color-red-400: rgba(255, 84, 89, 1);
            --color-red-500: rgba(192, 21, 47, 1);
            --color-orange-500: rgba(168, 75, 47, 1);

            --color-brown-600-rgb: 94, 82, 64;
            --color-teal-500-rgb: 33, 128, 141;
            --color-slate-900-rgb: 19, 52, 59;
            --color-red-500-rgb: 192, 21, 47;

            --color-bg-1: rgba(59, 130, 246, 0.08);
            --color-bg-2: rgba(245, 158, 11, 0.08);
            --color-bg-3: rgba(34, 197, 94, 0.08);

            --color-background: var(--color-cream-50);
            --color-surface: var(--color-cream-100);
            --color-text: var(--color-slate-900);
            --color-text-secondary: var(--color-slate-500);
            --color-primary: var(--color-teal-500);
            --color-primary-hover: var(--color-teal-600);
            --color-border: rgba(var(--color-brown-600-rgb), 0.2);
            --color-error: var(--color-red-500);
            --color-success: var(--color-teal-500);
            --color-warning: var(--color-orange-500);
            --color-focus-ring: rgba(var(--color-teal-500-rgb), 0.4);
            --color-btn-primary-text: var(--color-cream-50);

            --font-family-base: "Geist", "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            --font-family-mono: "Berkeley Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
            --font-size-base: 14px;
            --font-size-lg: 16px;
            --font-size-xl: 18px;
            --font-size-2xl: 20px;
            --font-size-3xl: 24px;
            --font-weight-normal: 400;
            --font-weight-medium: 500;
            --font-weight-semibold: 550;
            --line-height-normal: 1.5;

            --space-4: 4px;
            --space-6: 6px;
            --space-8: 8px;
            --space-12: 12px;
            --space-16: 16px;
            --space-20: 20px;
            --space-24: 24px;
            --space-32: 32px;

            --radius-base: 8px;
            --radius-lg: 12px;
            --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.04), 0 1px 2px rgba(0, 0, 0, 0.02);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.04), 0 2px 4px -1px rgba(0, 0, 0, 0.02);
            --duration-normal: 250ms;
            --ease-standard: cubic-bezier(0.16, 1, 0.3, 1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --color-background: rgba(31, 33, 33, 1);
                --color-surface: rgba(38, 40, 40, 1);
                --color-text: rgba(245, 245, 245, 1);
                --color-text-secondary: rgba(167, 169, 169, 0.7);
                --color-primary: var(--color-teal-300);
                --color-primary-hover: rgba(50, 184, 198, 1);
                --color-border: rgba(119, 124, 124, 0.3);
                --color-btn-primary-text: var(--color-slate-900);
            }
        }

        * {
            box-sizing: border-box;
        }

        html {
            font-size: var(--font-size-base);
            font-family: var(--font-family-base);
            line-height: var(--line-height-normal);
            color: var(--color-text);
            background-color: var(--color-background);
            -webkit-font-smoothing: antialiased;
        }

        body {
            margin: 0;
            padding: 0;
        }

        h1, h2, h3 {
            margin: 0;
            font-weight: var(--font-weight-semibold);
            color: var(--color-text);
        }

        h1 {
            font-size: var(--font-size-3xl);
        }

        h2 {
            font-size: var(--font-size-2xl);
        }

        h3 {
            font-size: var(--font-size-lg);
        }

        p {
            margin: 0 0 var(--space-16) 0;
            color: var(--color-text-secondary);
        }

        code {
            font-family: var(--font-family-mono);
            background-color: rgba(var(--color-brown-600-rgb), 0.12);
            padding: var(--space-4) var(--space-8);
            border-radius: 4px;
            font-size: 0.9em;
        }

        .container {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            padding: var(--space-16);
        }

        header {
            background: linear-gradient(135deg, var(--color-primary) 0%, rgba(var(--color-teal-500-rgb), 0.7) 100%);
            color: white;
            padding: var(--space-32) var(--space-16);
            margin-bottom: var(--space-32);
            border-radius: 0 0 var(--radius-lg) var(--radius-lg);
        }

        header h1 {
            color: white;
            margin-bottom: var(--space-8);
        }

        header p {
            color: rgba(255, 255, 255, 0.9);
            margin: 0;
        }

        .tabs {
            display: flex;
            gap: var(--space-8);
            margin-bottom: var(--space-24);
            border-bottom: 2px solid var(--color-border);
            overflow-x: auto;
        }

        .tab-btn {
            padding: var(--space-12) var(--space-16);
            background: none;
            border: none;
            color: var(--color-text-secondary);
            cursor: pointer;
            font-size: var(--font-size-base);
            font-weight: var(--font-weight-medium);
            border-bottom: 3px solid transparent;
            transition: all var(--duration-normal) var(--ease-standard);
            white-space: nowrap;
        }

        .tab-btn:hover {
            color: var(--color-text);
        }

        .tab-btn.active {
            color: var(--color-primary);
            border-bottom-color: var(--color-primary);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 300ms ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(8px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .form-group {
            margin-bottom: var(--space-20);
        }

        .form-label {
            display: block;
            margin-bottom: var(--space-8);
            font-weight: var(--font-weight-medium);
            font-size: var(--font-size-base);
            color: var(--color-text);
        }

        .form-control {
            display: block;
            width: 100%;
            padding: var(--space-12) var(--space-16);
            font-size: var(--font-size-base);
            color: var(--color-text);
            background-color: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-base);
            font-family: var(--font-family-base);
            transition: border-color var(--duration-normal) var(--ease-standard);
        }

        .form-control:focus {
            outline: none;
            border-color: var(--color-primary);
            box-shadow: 0 0 0 3px var(--color-focus-ring);
        }

        textarea.form-control {
            resize: vertical;
            min-height: 120px;
            font-family: var(--font-family-mono);
            font-size: 13px;
        }

        .input-group {
            display: flex;
            gap: var(--space-8);
            align-items: flex-end;
        }

        .input-group .form-control {
            flex: 1;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: var(--space-12) var(--space-20);
            border-radius: var(--radius-base);
            font-size: var(--font-size-base);
            font-weight: var(--font-weight-medium);
            cursor: pointer;
            transition: all var(--duration-normal) var(--ease-standard);
            border: none;
            text-decoration: none;
            gap: var(--space-8);
        }

        .btn:focus-visible {
            outline: none;
            box-shadow: 0 0 0 3px var(--color-focus-ring);
        }

        .btn--primary {
            background: var(--color-primary);
            color: var(--color-btn-primary-text);
        }

        .btn--primary:hover {
            background: var(--color-primary-hover);
        }

        .btn--primary:active {
            transform: scale(0.98);
        }

        .btn--secondary {
            background: rgba(var(--color-brown-600-rgb), 0.12);
            color: var(--color-text);
        }

        .btn--secondary:hover {
            background: rgba(var(--color-brown-600-rgb), 0.2);
        }

        .btn--sm {
            padding: var(--space-6) var(--space-12);
            font-size: var(--font-size-base);
        }

        .btn--block {
            width: 100%;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .card {
            background-color: var(--color-surface);
            border-radius: var(--radius-lg);
            border: 1px solid var(--color-border);
            box-shadow: var(--shadow-sm);
            overflow: hidden;
            transition: box-shadow var(--duration-normal) var(--ease-standard);
        }

        .card:hover {
            box-shadow: var(--shadow-md);
        }

        .card__body {
            padding: var(--space-24);
        }

        .card__header {
            padding: var(--space-16) var(--space-24);
            border-bottom: 1px solid var(--color-border);
            background: rgba(var(--color-brown-600-rgb), 0.02);
        }

        .card__header h3 {
            margin: 0;
        }

        .grid {
            display: grid;
            gap: var(--space-24);
        }

        @media (min-width: 768px) {
            .grid--2col {
                grid-template-columns: 1fr 1fr;
            }
        }

        .alert {
            padding: var(--space-16);
            border-radius: var(--radius-base);
            margin-bottom: var(--space-16);
            display: none;
        }

        .alert.active {
            display: block;
            animation: slideDown 300ms ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .alert--success {
            background: rgba(var(--color-teal-500-rgb), 0.15);
            border: 1px solid rgba(var(--color-teal-500-rgb), 0.25);
            color: var(--color-success);
        }

        .alert--error {
            background: rgba(var(--color-red-500-rgb), 0.15);
            border: 1px solid rgba(var(--color-red-500-rgb), 0.25);
            color: var(--color-error);
        }

        .alert--warning {
            background: rgba(168, 75, 47, 0.15);
            border: 1px solid rgba(168, 75, 47, 0.25);
            color: var(--color-warning);
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: var(--color-border);
            border-radius: 2px;
            overflow: hidden;
            margin: var(--space-8) 0;
        }

        .progress-bar__fill {
            height: 100%;
            background: var(--color-primary);
            width: 0%;
            transition: width 300ms ease-out;
        }

        .stat-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: var(--space-16);
            margin: var(--space-24) 0;
        }

        .stat-item {
            padding: var(--space-16);
            background: var(--color-background);
            border-radius: var(--radius-base);
            text-align: center;
        }

        .stat-value {
            font-size: var(--font-size-2xl);
            font-weight: var(--font-weight-semibold);
            color: var(--color-primary);
        }

        .stat-label {
            font-size: var(--font-size-base);
            color: var(--color-text-secondary);
            margin-top: var(--space-4);
        }

        .copy-btn {
            position: relative;
        }

        .copy-btn::after {
            content: 'Copy';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: var(--space-6) var(--space-12);
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 200ms;
            margin-bottom: var(--space-8);
        }

        .copy-btn.copied::after {
            content: 'Copied!';
            opacity: 1;
        }

        .note-box {
            background: var(--color-bg-1);
            border: 1px solid rgba(var(--color-teal-500-rgb), 0.2);
            padding: var(--space-16);
            border-radius: var(--radius-base);
            margin: var(--space-16) 0;
            font-size: var(--font-size-base);
            line-height: 1.6;
        }

        .note-box strong {
            color: var(--color-primary);
        }

        .hidden {
            display: none;
        }

        .flex {
            display: flex;
            gap: var(--space-8);
        }

        .flex-col {
            flex-direction: column;
        }

        .flex-between {
            justify-content: space-between;
            align-items: center;
        }

        .text-center {
            text-align: center;
        }

        .text-mono {
            font-family: var(--font-family-mono);
            font-size: 12px;
            word-break: break-all;
        }

        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(var(--color-teal-500-rgb), 0.3);
            border-top-color: var(--color-primary);
            border-radius: 50%;
            animation: spin 600ms linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        footer {
            margin-top: var(--space-32);
            padding-top: var(--space-24);
            border-top: 1px solid var(--color-border);
            text-align: center;
            color: var(--color-text-secondary);
            font-size: 12px;
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>üîê AES-256-GCM Encryption Vault</h1>
            <p>Client-side encryption with PBKDF2 key derivation and secure authentication</p>
        </div>
    </header>

    <div class="container">
        <!-- Alert Messages -->
        <div id="alert" class="alert"></div>

        <!-- Tab Navigation -->
        <div class="tabs">
            <button class="tab-btn active" data-tab="encrypt">Encrypt</button>
            <button class="tab-btn" data-tab="decrypt">Decrypt</button>
            <button class="tab-btn" data-tab="about">About & Notes</button>
        </div>

        <!-- ENCRYPT TAB -->
        <div id="encrypt" class="tab-content active">
            <div class="grid grid--2col">
                <div class="card">
                    <div class="card__header">
                        <h3>Text Input</h3>
                    </div>
                    <div class="card__body">
                        <form id="encryptForm">
                            <div class="form-group">
                                <label class="form-label">Plain Text (UTF-8)</label>
                                <textarea id="plaintext" class="form-control" placeholder="Enter text to encrypt...">Hello World!</textarea>
                            </div>

                            <div class="form-group">
                                <label class="form-label">Password</label>
                                <input type="password" id="password" class="form-control" placeholder="Enter a strong password..." value="MySecurePassword123">
                            </div>

                            <div class="form-group">
                                <label class="form-label">
                                    <input type="checkbox" id="showPassword"> Show password
                                </label>
                            </div>

                            <button type="submit" class="btn btn--primary btn--block">
                                <span id="encryptBtn">üîí Encrypt</span>
                            </button>
                        </form>

                        <div class="note-box">
                            <strong>üí° Info:</strong> Encryption happens entirely in your browser. Your password and plaintext never leave your device.
                        </div>
                    </div>
                </div>

                <div class="card">
                    <div class="card__header">
                        <h3>Encrypted Result</h3>
                    </div>
                    <div class="card__body">
                        <div class="form-group">
                            <label class="form-label">Cipher (Base64URL)</label>
                            <textarea id="ciphertext" class="form-control" placeholder="Encrypted output will appear here..." readonly></textarea>
                            <button type="button" class="btn btn--secondary btn--sm copy-btn" id="copyCipherBtn" style="margin-top: var(--space-8);">üìã Copy</button>
                        </div>

                        <div id="encryptStats" class="stat-group" style="display: none;">
                            <div class="stat-item">
                                <div class="stat-value" id="statPainSize">0</div>
                                <div class="stat-label">Plain bytes</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="statCipherSize">0</div>
                                <div class="stat-label">Cipher bytes</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="statTime">0ms</div>
                                <div class="stat-label">Time</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- DECRYPT TAB -->
        <div id="decrypt" class="tab-content">
            <div class="grid grid--2col">
                <div class="card">
                    <div class="card__header">
                        <h3>Decryption Input</h3>
                    </div>
                    <div class="card__body">
                        <form id="decryptForm">
                            <div class="form-group">
                                <label class="form-label">Cipher (Base64URL)</label>
                                <textarea id="cipherInput" class="form-control" placeholder="Paste encrypted text here..."></textarea>
                            </div>

                            <div class="form-group">
                                <label class="form-label">Password</label>
                                <input type="password" id="passwordDecrypt" class="form-control" placeholder="Enter the password used to encrypt...">
                            </div>

                            <div class="form-group">
                                <label class="form-label">
                                    <input type="checkbox" id="showPasswordDecrypt"> Show password
                                </label>
                            </div>

                            <button type="submit" class="btn btn--primary btn--block">
                                <span id="decryptBtn">üîì Decrypt</span>
                            </button>
                        </form>

                        <div class="note-box">
                            <strong>‚ö†Ô∏è Warning:</strong> Only decrypt data you trust. Verify the source before decryption.
                        </div>
                    </div>
                </div>

                <div class="card">
                    <div class="card__header">
                        <h3>Decrypted Text</h3>
                    </div>
                    <div class="card__body">
                        <div class="form-group">
                            <label class="form-label">Plain Text (UTF-8)</label>
                            <textarea id="plaintextResult" class="form-control" placeholder="Decrypted text will appear here..." readonly></textarea>
                            <button type="button" class="btn btn--secondary btn--sm copy-btn" id="copyPlainBtn" style="margin-top: var(--space-8);">üìã Copy</button>
                        </div>

                        <div id="decryptStats" class="stat-group" style="display: none;">
                            <div class="stat-item">
                                <div class="stat-value" id="statDecryptedSize">0</div>
                                <div class="stat-label">Plain bytes</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="statDecryptTime">0ms</div>
                                <div class="stat-label">Time</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ABOUT TAB -->
        <div id="about" class="tab-content">
            <div class="card">
                <div class="card__header">
                    <h3>Algorithm Overview</h3>
                </div>
                <div class="card__body">
                    <h4 style="margin-top: 0; margin-bottom: var(--space-12);">üîê Key Components</h4>

                    <div class="note-box">
                        <strong>PBKDF2 Key Derivation:</strong> Transforms your password into a cryptographic key using 100,000 iterations of HMAC-SHA256. Each encryption uses a unique random salt (stored in the cipher).
                    </div>

                    <div class="note-box">
                        <strong>AES-256-GCM Encryption:</strong> Industry-standard authenticated encryption. Ensures both confidentiality (encryption) and authenticity (tampering detection).
                    </div>

                    <div class="note-box">
                        <strong>Random IV (Initialization Vector):</strong> 12-byte cryptographically random value, fresh for each encryption. Ensures identical plaintexts produce different ciphertexts.
                    </div>

                    <div class="note-box">
                        <strong>CRC32 Checksum:</strong> Optional integrity check computed over salt, IV, and ciphertext. Helps detect corruption independent of AES authentication.
                    </div>

                    <div class="note-box">
                        <strong>Base64URL Encoding:</strong> Safe text representation for transport and storage. Uses URL-safe alphabet (no +/ characters).
                    </div>

                    <h4 style="margin-top: var(--space-24); margin-bottom: var(--space-12);">üß™ Testing Instructions</h4>

                    <p><strong>Test Case 1: Basic English Text</strong></p>
                    <ol style="margin: var(--space-8) 0; padding-left: var(--space-24);">
                        <li>Plaintext: <code>Hello World!</code></li>
                        <li>Password: <code>TestPassword123</code></li>
                        <li>Expected: Encryption succeeds, ciphertext is ~100 chars (Base64URL)</li>
                        <li>Decrypt with same password ‚Üí same plaintext</li>
                        <li>Try wrong password ‚Üí <strong>MUST</strong> fail with auth error</li>
                    </ol>

                    <p><strong>Test Case 2: Unicode & Multi-language</strong></p>
                    <ol style="margin: var(--space-8) 0; padding-left: var(--space-24);">
                        <li>Plaintext: <code>–ü—Ä–∏–≤–µ—Ç –º–∏—Ä! ‰Ω†Â•Ω‰∏ñÁïå üåç</code></li>
                        <li>Password: <code>–ü–∞—Ä–æ–ª—å123</code></li>
                        <li>Expected: UTF-8 handled correctly, emoji preserved</li>
                        <li>Decrypt: Exact match including emoji</li>
                    </ol>

                    <p><strong>Test Case 3: Large Text & Performance</strong></p>
                    <ol style="margin: var(--space-8) 0; padding-left: var(--space-24);">
                        <li>Plaintext: 10KB of Lorem Ipsum</li>
                        <li>Observe encryption time (should be &lt;1 second)</li>
                        <li>Observe mobile responsiveness (no UI freeze)</li>
                    </ol>

                    <p><strong>Test Case 4: Special Characters & Edge Cases</strong></p>
                    <ol style="margin: var(--space-8) 0; padding-left: var(--space-24);">
                        <li>Plaintext: <code>!@#$%^&*()_+-=[]{}|;:',&lt;&gt;?/"</code></li>
                        <li>Password with spaces and symbols</li>
                        <li>Expected: All characters preserved exactly</li>
                    </ol>

                    <p><strong>Test Case 5: Reproducibility & Randomness</strong></p>
                    <ol style="margin: var(--space-8) 0; padding-left: var(--space-24);">
                        <li>Encrypt same plaintext twice with same password</li>
                        <li>Ciphertexts <strong>MUST be different</strong> (due to random salt & IV)</li>
                        <li>Both must decrypt to same plaintext</li>
                    </ol>

                    <h4 style="margin-top: var(--space-24); margin-bottom: var(--space-12);">‚ö†Ô∏è Security Warnings</h4>

                    <div class="alert alert--warning" style="display: block; padding: var(--space-16);">
                        <strong>Client-Side Only:</strong> Encryption runs entirely in your browser. No data sent to servers. However, JavaScript in browsers can be vulnerable to XSS attacks. Use HTTPS only.
                    </div>

                    <div class="alert alert--warning" style="display: block; padding: var(--space-16);">
                        <strong>Password Strength:</strong> PBKDF2 with 100k iterations slows down brute-force, but weak passwords are still vulnerable. Use passwords with 12+ characters, mixed case, numbers, and symbols.
                    </div>

                    <div class="alert alert--warning" style="display: block; padding: var(--space-16);">
                        <strong>Device Security:</strong> This tool cannot protect against keyloggers, malware, or compromised devices. Ensure your device is clean.
                    </div>

                    <div class="alert alert--warning" style="display: block; padding: var(--space-16);">
                        <strong>No Key Recovery:</strong> If you forget the password, encrypted data is permanently inaccessible. There is no "forgot password" recovery.
                    </div>

                    <h4 style="margin-top: var(--space-24); margin-bottom: var(--space-12);">üõ†Ô∏è Technical Details</h4>

                    <p><strong>Cipher Format (Base64URL):</strong></p>
                    <code style="display: block; padding: var(--space-12); background: var(--color-bg-3); border-radius: var(--radius-base); margin: var(--space-8) 0; overflow-x: auto;">
                        [32-byte salt] + [12-byte IV] + [ciphertext] + [16-byte auth tag]
                    </code>

                    <p><strong>PBKDF2 Parameters:</strong></p>
                    <ul style="margin: var(--space-8) 0; padding-left: var(--space-24);">
                        <li>Algorithm: HMAC-SHA256</li>
                        <li>Iterations: 100,000 (balance security & UX)</li>
                        <li>Key Length: 256 bits (32 bytes)</li>
                        <li>Salt: 32 bytes random (unique per encryption)</li>
                    </ul>

                    <p><strong>AES-GCM Parameters:</strong></p>
                    <ul style="margin: var(--space-8) 0; padding-left: var(--space-24);">
                        <li>Mode: Galois/Counter Mode (authenticated)</li>
                        <li>Key Size: 256 bits</li>
                        <li>IV (Nonce): 12 bytes random</li>
                        <li>Auth Tag: 16 bytes (128-bit authentication)</li>
                    </ul>

                    <h4 style="margin-top: var(--space-24); margin-bottom: var(--space-12);">üìã Browser Compatibility</h4>
                    <p>Requires modern browser with Web Crypto API support (Chrome 37+, Firefox 34+, Safari 11+, Edge 79+). No external libraries used.</p>
                </div>
            </div>
        </div>
    </div>

    <footer>
        <p>üîê AES-256-GCM Encryption Vault | No data sent to servers | Use HTTPS only | All operations client-side</p>
    </footer>

    <script>
        /**
         * ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
         * ‚ïë                    AES-256-GCM ENCRYPTION VAULT                                ‚ïë
         * ‚ïë                   Client-Side Encryption Application                           ‚ïë
         * ‚ïë                                                                                ‚ïë
         * ‚ïë  README FOR DEVELOPERS:                                                       ‚ïë
         * ‚ïë  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ    ‚ïë
         * ‚ïë                                                                                ‚ïë
         * ‚ïë  ALGORITHM DESCRIPTION:                                                       ‚ïë
         * ‚ïë  This application implements secure client-side encryption using:             ‚ïë
         * ‚ïë                                                                                ‚ïë
         * ‚ïë  1. PBKDF2-SHA256: Password-Based Key Derivation                              ‚ïë
         * ‚ïë     - Transforms passwords into 256-bit cryptographic keys                    ‚ïë
         * ‚ïë     - 100,000 iterations resist brute-force attacks                           ‚ïë
         * ‚ïë     - Unique 32-byte salt per encryption                                      ‚ïë
         * ‚ïë                                                                                ‚ïë
         * ‚ïë  2. AES-256-GCM: Advanced Encryption Standard                                 ‚ïë
         * ‚ïë     - Provides both confidentiality and authenticity                          ‚ïë
         * ‚ïë     - 256-bit key, 12-byte IV (nonce)                                         ‚ïë
         * ‚ïë     - Detects tampering via 16-byte authentication tag                        ‚ïë
         * ‚ïë                                                                                ‚ïë
         * ‚ïë  3. Base64URL Encoding: Safe Text Representation                              ‚ïë
         * ‚ïë     - URL-safe alphabet (no + / characters)                                   ‚ïë
         * ‚ïë     - Preserves all binary data in text form                                  ‚ïë
         * ‚ïë                                                                                ‚ïë
         * ‚ïë  CIPHER FORMAT:                                                               ‚ïë
         * ‚ïë  [32-byte salt] + [12-byte IV] + [encrypted data] + [16-byte auth tag]       ‚ïë
         * ‚ïë  All components stored in single Base64URL string for easy transport.         ‚ïë
         * ‚ïë                                                                                ‚ïë
         * ‚ïë  SECURITY WARNINGS:                                                           ‚ïë
         * ‚ïë  ‚ö†Ô∏è  This is client-side JavaScript encryption. While implementation is       ‚ïë
         * ‚ïë      correct, JavaScript in browsers can be vulnerable to:                   ‚ïë
         * ‚ïë      - XSS (Cross-Site Scripting) attacks                                    ‚ïë
         * ‚ïë      - Keyloggers and malware on infected devices                             ‚ïë
         * ‚ïë      - Man-in-the-middle attacks over HTTP (use HTTPS only!)                  ‚ïë
         * ‚ïë                                                                                ‚ïë
         * ‚ïë  USE CASES:                                                                   ‚ïë
         * ‚ïë  ‚úì Sensitive notes (passwords, API keys)                                      ‚ïë
         * ‚ïë  ‚úì Personal documents (medical, financial records)                            ‚ïë
         * ‚ïë  ‚úì Educational/demonstration purposes                                         ‚ïë
         * ‚ïë  ‚úó DO NOT USE for: bank credentials, SSN/passport numbers (use secure        ‚ïë
         * ‚ïë    password managers and official banking apps instead)                       ‚ïë
         * ‚ïë                                                                                ‚ïë
         * ‚ïë  NO EXTERNAL DEPENDENCIES: All algorithms implemented from scratch.           ‚ïë
         * ‚ïë  Uses native Web Crypto API (available in all modern browsers).               ‚ïë
         * ‚ïë                                                                                ‚ïë
         * ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
         */

        // ============================================================================
        // UTILITY FUNCTIONS - Random number generation, encoding/decoding
        // ============================================================================

        /**
         * Generates cryptographically secure random bytes using Web Crypto API.
         * Essential for unique salts and IVs - ensures security of each encryption.
         * 
         * @param {number} length - Number of random bytes to generate (e.g., 32 for salt)
         * @returns {Uint8Array} Array of random bytes
         * 
         * Why this matters: If random bytes were predictable, an attacker could
         * predict salts/IVs and precompute attacks. Web Crypto guarantees OS-level randomness.
         */
        function generateRandomBytes(length) {
            return crypto.getRandomValues(new Uint8Array(length));
        }

        /**
         * Encodes Uint8Array to Base64URL string (RFC 4648).
         * Removes padding and replaces URL-unsafe characters (+ ‚Üí -, / ‚Üí _).
         * Needed for safe transport/display of binary cipher data.
         * 
         * @param {Uint8Array} bytes - Binary data to encode
         * @returns {string} Base64URL encoded string
         */
        function bytesToBase64URL(bytes) {
            // Step 1: Convert bytes to binary string
            let binary = '';
            for (let i = 0; i < bytes.length; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            
            // Step 2: Use native btoa() for standard Base64
            const base64 = btoa(binary);
            
            // Step 3: Convert to Base64URL (RFC 4648)
            // Replace + with -, / with _, and remove padding =
            return base64
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/=/g, '');
        }

        /**
         * Decodes Base64URL string back to Uint8Array.
         * Reverses the URL-safe transformations and adds padding if needed.
         * 
         * @param {string} base64url - Base64URL encoded string
         * @returns {Uint8Array} Decoded binary data
         * @throws {Error} If decoding fails
         */
        function base64URLToBytes(base64url) {
            try {
                // Step 1: Restore standard Base64 format
                const base64 = base64url
                    .replace(/-/g, '+')
                    .replace(/_/g, '/');
                
                // Step 2: Add padding if needed (Base64 length must be multiple of 4)
                const padded = base64 + '='.repeat((4 - (base64.length % 4)) % 4);
                
                // Step 3: Decode using native atob()
                const binary = atob(padded);
                
                // Step 4: Convert to Uint8Array
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) {
                    bytes[i] = binary.charCodeAt(i);
                }
                
                return bytes;
            } catch (e) {
                throw new Error('Invalid Base64URL format: ' + e.message);
            }
        }

        /**
         * Converts text string to Uint8Array using UTF-8 encoding.
         * JavaScript strings are UTF-16 internally, but cryptography needs UTF-8.
         * TextEncoder handles this conversion correctly.
         * 
         * @param {string} text - Text to encode
         * @returns {Uint8Array} UTF-8 encoded bytes
         */
        function stringToBytes(text) {
            return new TextEncoder().encode(text);
        }

        /**
         * Converts Uint8Array back to text string using UTF-8 decoding.
         * Handles all UTF-8 characters including emoji, CJK, Cyrillic, etc.
         * 
         * @param {Uint8Array} bytes - UTF-8 encoded bytes
         * @returns {string} Decoded text
         * @throws {Error} If bytes are not valid UTF-8
         */
        function bytesToString(bytes) {
            try {
                return new TextDecoder('utf-8').decode(bytes);
            } catch (e) {
                throw new Error('Invalid UTF-8 in decrypted data: ' + e.message);
            }
        }

        // ============================================================================
        // CRC32 CHECKSUM - Integrity verification (optional, independent of AES)
        // ============================================================================

        /**
         * Computes CRC32 checksum over data.
         * Detects accidental corruption independent of AES-GCM authentication.
         * Useful for debugging and additional integrity assurance.
         * 
         * Algorithm: Polynomial 0xEDB88320 (reversed form), standard CRC32.
         * Performance: O(n) - linear in data length.
         * 
         * @param {Uint8Array} data - Data to checksum
         * @returns {number} 32-bit CRC32 value
         */
        function computeCRC32(data) {
            // Precomputed lookup table for fast CRC32 computation
            // Each value is CRC32(i) for byte i, using polynomial 0xEDB88320
            const table = new Uint32Array(256);
            
            // Initialize lookup table on first call
            if (table[255] === 0) {
                for (let n = 0; n < 256; n++) {
                    let crc = n;
                    for (let k = 0; k < 8; k++) {
                        crc = (crc & 1) ? (0xEDB88320 ^ (crc >>> 1)) : (crc >>> 1);
                    }
                    table[n] = crc >>> 0; // Ensure unsigned 32-bit
                }
            }
            
            // Compute CRC32 of data
            let crc = 0xFFFFFFFF; // Initial value (standard)
            for (let i = 0; i < data.length; i++) {
                const byte = data[i];
                crc = table[(crc ^ byte) & 0xFF] ^ (crc >>> 8);
            }
            
            // Final XOR to complete CRC32
            return (crc ^ 0xFFFFFFFF) >>> 0; // Ensure unsigned 32-bit
        }

        // ============================================================================
        // PBKDF2 KEY DERIVATION - Password ‚Üí Cryptographic Key
        // ============================================================================

        /**
         * Derives a cryptographic key from password using PBKDF2-SHA256.
         * 
         * PBKDF2 = Password-Based Key Derivation Function version 2
         * Applies HMAC-SHA256 iteratively to slow down brute-force attacks.
         * Each iteration takes ~1ms on modern hardware, so 100k iterations ‚âà 100ms.
         * This makes rainbow tables and GPU attacks impractical.
         * 
         * @param {string} password - User's password
         * @param {Uint8Array} salt - Unique salt (32 bytes) to prevent rainbow tables
         * @param {number} iterations - Number of HMAC iterations (100,000 recommended)
         * @returns {Promise<CryptoKey>} Derived key for AES-256-GCM encryption
         * 
         * Security notes:
         * - Salt MUST be random and unique per password (stored in cipher)
         * - Iterations SHOULD increase over time as computers get faster
         * - 100,000 is current OWASP recommendation (2024)
         */
        async function pbkdf2DeriveKey(password, salt, iterations = 100000) {
            // Step 1: Convert password string to bytes
            const passwordBytes = stringToBytes(password);
            
            // Step 2: Import password as raw key material for PBKDF2
            const baseKey = await crypto.subtle.importKey(
                'raw',                          // Password is raw bytes
                passwordBytes,                  // The password
                'PBKDF2',                       // Algorithm
                false,                          // Not extractable
                ['deriveBits']                  // Usage: derive bits from password
            );
            
            // Step 3: Derive key bits using PBKDF2
            const derivedBits = await crypto.subtle.deriveBits(
                {
                    name: 'PBKDF2',
                    salt: salt,                 // Unique salt for this password
                    hash: 'SHA-256',            // HMAC-SHA256 function
                    iterations: iterations      // 100,000 iterations = ~100ms
                },
                baseKey,                        // Password key material
                256                             // Derive 256 bits (32 bytes)
            );
            
            // Step 4: Import derived bits as AES key for encryption/decryption
            const key = await crypto.subtle.importKey(
                'raw',                          // Derived bits are raw key
                derivedBits,                    // The 256 bits we derived
                { name: 'AES-GCM' },            // Will be used with AES-GCM
                false,                          // Not extractable
                ['encrypt', 'decrypt']          // Can encrypt and decrypt
            );
            
            return key;
        }

        // ============================================================================
        // AES-256-GCM ENCRYPTION - Secure Authenticated Encryption
        // ============================================================================

        /**
         * Encrypts plaintext using AES-256-GCM.
         * 
         * AES-GCM = Advanced Encryption Standard in Galois/Counter Mode
         * Provides:
         * - Confidentiality: Plaintext unreadable without key
         * - Authenticity: Detects any tampering with ciphertext
         * 
         * Complete process:
         * 1. Generate random 32-byte salt (for PBKDF2)
         * 2. Generate random 12-byte IV/nonce (for AES-GCM)
         * 3. Derive 256-bit key from password using PBKDF2-SHA256
         * 4. Encrypt plaintext with AES-256-GCM (produces auth tag)
         * 5. Combine: salt + IV + ciphertext + auth tag
         * 6. Encode as Base64URL for text transport
         * 
         * @param {string} plaintext - Text to encrypt (any UTF-8)
         * @param {string} password - User's password (any length/characters)
         * @returns {Promise<string>} Base64URL cipher containing salt, IV, encrypted data, auth tag
         * @throws {Error} If encryption fails (low on memory, etc.)
         */
        async function encryptAES256GCM(plaintext, password) {
            try {
                // Step 1: Generate cryptographically secure random salt
                // 32 bytes = 256 bits, provides strength against rainbow tables
                const salt = generateRandomBytes(32);
                
                // Step 2: Generate cryptographically secure random IV (nonce)
                // 12 bytes is standard for GCM mode
                // IV MUST be unique per key (satisfied by random salt per password)
                const iv = generateRandomBytes(12);
                
                // Step 3: Derive AES key from password using PBKDF2
                const key = await pbkdf2DeriveKey(password, salt, 100000);
                
                // Step 4: Convert plaintext to UTF-8 bytes
                const plaintextBytes = stringToBytes(plaintext);
                
                // Step 5: Encrypt using AES-256-GCM
                // This produces ciphertext + 16-byte authentication tag (appended)
                const cipherBytes = await crypto.subtle.encrypt(
                    {
                        name: 'AES-GCM',
                        iv: iv,                 // 12-byte nonce
                        tagLength: 128          // 16-byte authentication tag
                    },
                    key,                        // 256-bit AES key
                    plaintextBytes              // Plaintext to encrypt
                );
                
                // Step 6: Combine salt + IV + ciphertext + auth tag into single buffer
                const combined = new Uint8Array(
                    salt.length + iv.length + cipherBytes.byteLength
                );
                combined.set(salt, 0);                          // Bytes 0-31: salt
                combined.set(iv, salt.length);                  // Bytes 32-43: IV
                combined.set(
                    new Uint8Array(cipherBytes),                // Bytes 44+: ciphertext + tag
                    salt.length + iv.length
                );
                
                // Step 7: Encode as Base64URL for safe text transport
                const cipher = bytesToBase64URL(combined);
                
                return cipher;
            } catch (error) {
                throw new Error('Encryption failed: ' + error.message);
            }
        }

        /**
         * Decrypts AES-256-GCM ciphertext using password.
         * 
         * Reverse process of encryption:
         * 1. Decode Base64URL to binary
         * 2. Extract salt (first 32 bytes)
         * 3. Extract IV (next 12 bytes)
         * 4. Extract ciphertext + auth tag (remaining bytes)
         * 5. Derive same key from password + salt using PBKDF2
         * 6. Decrypt with AES-GCM (verifies auth tag)
         * 7. Decode UTF-8 to text
         * 
         * @param {string} cipher - Base64URL cipher from encryption
         * @param {string} password - Original password
         * @returns {Promise<string>} Decrypted plaintext
         * @throws {Error} If cipher is invalid, password wrong, or tampering detected
         */
        async function decryptAES256GCM(cipher, password) {
            try {
                // Step 1: Decode Base64URL cipher to binary
                const combined = base64URLToBytes(cipher);
                
                // Validate minimum size: 32 (salt) + 12 (IV) + 1 (min ciphertext) + 16 (tag) = 61
                if (combined.length < 61) {
                    throw new Error('Cipher too short - possibly corrupted');
                }
                
                // Step 2: Extract salt (first 32 bytes)
                const salt = combined.slice(0, 32);
                
                // Step 3: Extract IV (next 12 bytes)
                const iv = combined.slice(32, 44);
                
                // Step 4: Extract ciphertext + auth tag (remaining bytes)
                const cipherBytes = combined.slice(44);
                
                // Step 5: Derive same key from password + salt using PBKDF2
                // Must use same iterations (100,000) as encryption
                const key = await pbkdf2DeriveKey(password, salt, 100000);
                
                // Step 6: Decrypt using AES-256-GCM
                // Auth tag is verified automatically. If tampering detected, throws error.
                const plaintextBytes = await crypto.subtle.decrypt(
                    {
                        name: 'AES-GCM',
                        iv: iv,                 // Extract IV from cipher
                        tagLength: 128          // 16-byte tag verified during decryption
                    },
                    key,                        // Derived from password + salt
                    cipherBytes                 // Ciphertext + auth tag
                );
                
                // Step 7: Convert UTF-8 bytes back to text
                const plaintext = bytesToString(new Uint8Array(plaintextBytes));
                
                return plaintext;
            } catch (error) {
                // Distinguish between wrong password and other errors
                if (error.name === 'OperationError' || error.message.includes('decrypt')) {
                    throw new Error('Decryption failed - wrong password or corrupted cipher');
                }
                throw new Error('Decryption error: ' + error.message);
            }
        }

        // ============================================================================
        // UI MANAGEMENT - Tabs, alerts, button states
        // ============================================================================

        /**
         * Displays alert message to user.
         * Automatically hides after 5 seconds unless dismissed.
         * 
         * @param {string} message - Message to display
         * @param {string} type - Alert type: 'success', 'error', or 'warning'
         */
        function showAlert(message, type = 'success') {
            const alertEl = document.getElementById('alert');
            alertEl.className = `alert alert--${type} active`;
            alertEl.textContent = message;
            
            // Auto-dismiss after 5 seconds
            setTimeout(() => {
                alertEl.classList.remove('active');
            }, 5000);
        }

        /**
         * Enables/disables button and shows loading spinner.
         * Provides user feedback during long-running operations.
         * 
         * @param {HTMLElement} btn - Button element
         * @param {boolean} isLoading - true to show spinner, false to restore normal state
         */
        function setButtonLoading(btn, isLoading) {
            if (isLoading) {
                btn.disabled = true;
                btn.innerHTML = '<span class="loading"></span> Processing...';
            } else {
                btn.disabled = false;
                btn.innerHTML = btn.dataset.originalText || 'Encrypt';
            }
        }

        /**
         * Switches active tab in UI.
         * Hides all tabs, shows selected one.
         * 
         * @param {string} tabName - Tab ID to activate
         */
        function switchTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Deactivate all buttons
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab
            const tab = document.getElementById(tabName);
            if (tab) {
                tab.classList.add('active');
            }
            
            // Activate corresponding button
            const btn = document.querySelector(`[data-tab="${tabName}"]`);
            if (btn) {
                btn.classList.add('active');
            }
        }

        /**
         * Copies text to clipboard and shows feedback.
         * Updates button text to show "Copied!" temporarily.
         * 
         * @param {string} text - Text to copy
         * @param {HTMLElement} btn - Button that triggered copy
         */
        function copyToClipboard(text, btn) {
            navigator.clipboard.writeText(text).then(() => {
                btn.classList.add('copied');
                setTimeout(() => {
                    btn.classList.remove('copied');
                }, 2000);
            }).catch(() => {
                showAlert('Failed to copy to clipboard', 'error');
            });
        }

        // ============================================================================
        // EVENT HANDLERS - Form submission and button clicks
        // ============================================================================

        /**
         * Handles encryption form submission.
         * Validates inputs, encrypts plaintext, displays results.
         * Measures and displays encryption time and data sizes.
         */
        document.getElementById('encryptForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const plaintext = document.getElementById('plaintext').value;
            const password = document.getElementById('password').value;
            const encryptBtn = document.getElementById('encryptBtn');
            
            // Validation
            if (!plaintext.trim()) {
                showAlert('Please enter text to encrypt', 'warning');
                return;
            }
            if (!password) {
                showAlert('Please enter a password', 'warning');
                return;
            }
            
            // Store original button text and show loading state
            encryptBtn.dataset.originalText = encryptBtn.innerHTML;
            setButtonLoading(encryptBtn, true);
            
            try {
                // Measure encryption time
                const startTime = performance.now();
                const cipher = await encryptAES256GCM(plaintext, password);
                const endTime = performance.now();
                const encryptTime = (endTime - startTime).toFixed(2);
                
                // Display results
                document.getElementById('ciphertext').value = cipher;
                
                // Update statistics
                const plainBytes = stringToBytes(plaintext).length;
                const cipherBytes = base64URLToBytes(cipher).length;
                
                document.getElementById('statPainSize').textContent = plainBytes;
                document.getElementById('statCipherSize').textContent = cipherBytes;
                document.getElementById('statTime').textContent = encryptTime + 'ms';
                document.getElementById('encryptStats').style.display = 'grid';
                
                showAlert(`‚úì Encryption successful (${encryptTime}ms)`, 'success');
            } catch (error) {
                showAlert('Encryption error: ' + error.message, 'error');
                console.error('Encryption error:', error);
            } finally {
                setButtonLoading(encryptBtn, false);
                encryptBtn.innerHTML = encryptBtn.dataset.originalText;
            }
        });

        /**
         * Handles decryption form submission.
         * Validates cipher format, decrypts with password, displays plaintext.
         * Handles decryption errors (wrong password, corrupted cipher).
         */
        document.getElementById('decryptForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const cipher = document.getElementById('cipherInput').value;
            const password = document.getElementById('passwordDecrypt').value;
            const decryptBtn = document.getElementById('decryptBtn');
            
            // Validation
            if (!cipher.trim()) {
                showAlert('Please paste encrypted text', 'warning');
                return;
            }
            if (!password) {
                showAlert('Please enter the password', 'warning');
                return;
            }
            
            // Store original button text and show loading state
            decryptBtn.dataset.originalText = decryptBtn.innerHTML;
            setButtonLoading(decryptBtn, true);
            
            try {
                // Measure decryption time
                const startTime = performance.now();
                const plaintext = await decryptAES256GCM(cipher, password);
                const endTime = performance.now();
                const decryptTime = (endTime - startTime).toFixed(2);
                
                // Display results
                document.getElementById('plaintextResult').value = plaintext;
                
                // Update statistics
                const decryptedBytes = stringToBytes(plaintext).length;
                document.getElementById('statDecryptedSize').textContent = decryptedBytes;
                document.getElementById('statDecryptTime').textContent = decryptTime + 'ms';
                document.getElementById('decryptStats').style.display = 'grid';
                
                showAlert(`‚úì Decryption successful (${decryptTime}ms)`, 'success');
            } catch (error) {
                showAlert('Decryption failed: ' + error.message, 'error');
                console.error('Decryption error:', error);
            } finally {
                setButtonLoading(decryptBtn, false);
                decryptBtn.innerHTML = decryptBtn.dataset.originalText;
            }
        });

        /**
         * Show/hide password toggles for better UX.
         * Users can reveal password to verify correct typing.
         */
        document.getElementById('showPassword').addEventListener('change', (e) => {
            const input = document.getElementById('password');
            input.type = e.target.checked ? 'text' : 'password';
        });

        document.getElementById('showPasswordDecrypt').addEventListener('change', (e) => {
            const input = document.getElementById('passwordDecrypt');
            input.type = e.target.checked ? 'text' : 'password';
        });

        /**
         * Tab navigation click handlers.
         * Switch between Encrypt, Decrypt, and About tabs.
         */
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const tabName = btn.getAttribute('data-tab');
                switchTab(tabName);
            });
        });

        /**
         * Copy button handlers.
         * Allow users to quickly copy encrypted/decrypted results.
         */
        document.getElementById('copyCipherBtn').addEventListener('click', () => {
            const cipher = document.getElementById('ciphertext').value;
            if (cipher) {
                copyToClipboard(cipher, document.getElementById('copyCipherBtn'));
                showAlert('Ciphertext copied to clipboard', 'success');
            }
        });

        document.getElementById('copyPlainBtn').addEventListener('click', () => {
            const plaintext = document.getElementById('plaintextResult').value;
            if (plaintext) {
                copyToClipboard(plaintext, document.getElementById('copyPlainBtn'));
                showAlert('Plaintext copied to clipboard', 'success');
            }
        });

        /**
         * Initialize application on page load.
         * Show welcome alert with testing instructions.
         */
        window.addEventListener('load', () => {
            showAlert('Welcome! Use test data to explore. See "About & Notes" tab for details.', 'success');
        });
    </script>
</body>
</html>
