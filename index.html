<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Multicolor Square — Pro</title>
<style>
  :root{
    --bg:#070a10;
    --panel: rgba(16,20,30,.62);
    --panel2: rgba(10,14,22,.72);
    --line: rgba(255,255,255,.10);
    --text: rgba(245,250,255,.92);
    --muted: rgba(190,205,223,.70);
    --a1:#6E7BFF;
    --a2:#20D2A2;
    --a3:#FF5CAD;
    --shadow: 0 28px 90px rgba(0,0,0,.6);
    --r: 18px;
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    --sans: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;
    --ease: cubic-bezier(.2,.85,.2,1);

    /* calm background knobs */
    --mx: .5; --my:.5;
    --bgSpeed: 1;
    --bgHue: 206;      /* 160..260 */
    --bgCalm: 1;       /* 0..1 */
  }

  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family: var(--sans);
    color: var(--text);
    background: var(--bg);
    overflow:hidden;
  }

  /* Calm infinite background (aurora + glow + grain) */
  body::before{
    content:"";
    position: fixed;
    inset:-25%;
    z-index:-2;
    background:
      radial-gradient(950px 760px at calc(22% + var(--mx)*12%) calc(18% + var(--my)*10%),
        hsla(calc(var(--bgHue) + 20), 92%, 70%, .20), transparent 65%),
      radial-gradient(1100px 860px at calc(76% - var(--mx)*10%) calc(26% + var(--my)*8%),
        hsla(calc(var(--bgHue) - 40), 86%, 60%, .14), transparent 66%),
      radial-gradient(980px 780px at calc(54% + var(--mx)*6%) calc(86% - var(--my)*10%),
        hsla(calc(var(--bgHue) + 110), 85%, 70%, .10), transparent 62%),
      linear-gradient(180deg, rgba(10,12,18,.94), rgba(7,10,16,.98));
    filter: saturate(calc(1.02 + var(--bgCalm)*.12)) contrast(1.02);
    animation: calmDrift calc(58s * var(--bgSpeed)) var(--ease) infinite alternate;
    transform: translateZ(0);
  }
  @keyframes calmDrift{
    0%{ background-position: 0% 32%; transform: scale(1.02) rotate(-.10deg); }
    100%{ background-position: 100% 70%; transform: scale(1.06) rotate(.10deg); }
  }

  body::after{
    content:"";
    position: fixed;
    inset:0;
    z-index:-1;
    pointer-events:none;
    opacity: .085;
    background:
      radial-gradient(circle at 50% 38%, rgba(255,255,255,.05), transparent 55%),
      url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='240' height='240'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.85' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='240' height='240' filter='url(%23n)' opacity='.9'/%3E%3C/svg%3E");
    mix-blend-mode: overlay;
    animation: calmGrain calc(10s * var(--bgSpeed)) linear infinite;
    mask-image: radial-gradient(circle at 50% 40%, black 0 62%, transparent 82%);
  }
  @keyframes calmGrain{
    from{ transform: translate3d(0,0,0); }
    to{ transform: translate3d(-2%, 1%, 0); }
  }

  @media (prefers-reduced-motion: reduce){
    body::before, body::after{ animation:none !important; }
  }

  /* Layout */
  .app{
    height:100%;
    display:grid;
    grid-template-columns: 360px 1fr;
    gap: 14px;
    padding: 14px;
  }
  @media (max-width: 980px){
    body{ overflow:auto; }
    .app{ grid-template-columns: 1fr; }
  }

  .panel{
    border: 1px solid var(--line);
    border-radius: var(--r);
    background: linear-gradient(180deg, var(--panel), var(--panel2));
    box-shadow: var(--shadow);
    backdrop-filter: blur(14px);
    overflow:hidden;
  }

  .pHead{
    padding: 14px 14px 10px;
    border-bottom: 1px solid rgba(255,255,255,.09);
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
  }
  .brand{ display:flex; align-items:center; gap:12px; }
  .logo{
    width: 36px; height: 36px;
    border-radius: 14px;
    background: conic-gradient(from 180deg, var(--a1), var(--a2), var(--a3), var(--a1));
    box-shadow: 0 0 0 3px rgba(255,255,255,.06), 0 20px 60px rgba(110,123,255,.18);
    position:relative;
    overflow:hidden;
  }
  .logo::after{
    content:"";
    position:absolute; inset:-70%;
    background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.22), transparent 55%);
    animation: sheen 3.4s var(--ease) infinite;
  }
  @keyframes sheen{
    0%{ transform: translate3d(-12%, -10%, 0) rotate(8deg); opacity:.16; }
    50%{ transform: translate3d(12%, 10%, 0) rotate(18deg); opacity:.26; }
    100%{ transform: translate3d(-12%, -10%, 0) rotate(8deg); opacity:.16; }
  }
  @media (prefers-reduced-motion: reduce){ .logo::after{ animation:none !important; } }

  .name{
    margin:0;
    font-size: 14px;
    letter-spacing: 2.6px;
    text-transform: uppercase;
  }
  .mini{
    margin-top: 4px;
    font-family: var(--mono);
    font-size: 12px;
    color: var(--muted);
  }

  .pBody{ padding: 12px 14px 14px; display:grid; gap:10px; }
  .row{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
  .row1{ display:grid; grid-template-columns: 1fr; gap:10px; }
  .row3{ display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px; }
  .row4{ display:grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap:10px; }

  .field{
    border: 1px solid rgba(255,255,255,.12);
    background: rgba(255,255,255,.04);
    border-radius: 14px;
    padding: 10px;
    display:flex;
    flex-direction:column;
    gap:6px;
  }
  .lab{
    font-family: var(--mono);
    font-size: 12px;
    color: rgba(190,205,223,.70);
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
  }

  input[type="range"]{ width:100%; }
  input[type="color"]{
    width: 100%;
    height: 34px;
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,.14);
    background: transparent;
    padding: 0;
  }
  select, button{ font-family: inherit; }
  select{
    height:34px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.14);
    background:rgba(255,255,255,.04);
    color: var(--text);
    padding: 0 10px;
  }

  .btnRow{ display:flex; gap:10px; flex-wrap:wrap; }
  .btn{
    border: 1px solid rgba(110,123,255,.45);
    background: rgba(110,123,255,.14);
    color: var(--text);
    padding: 10px 12px;
    border-radius: 14px;
    cursor:pointer;
    font-size: 13px;
    user-select:none;
    position:relative;
    overflow:hidden;
    transition: transform 200ms var(--ease), background 200ms var(--ease), border-color 200ms var(--ease);
  }
  .btn:hover{ transform: translateY(-1px); background: rgba(110,123,255,.20); border-color: rgba(32,210,162,.40); }
  .btn:active{ transform: translateY(0) scale(.99); }
  .btn.ghost{
    border-color: rgba(255,255,255,.14);
    background: rgba(255,255,255,.04);
    color: var(--muted);
  }
  .btn.ghost:hover{ background: rgba(255,255,255,.06); color: var(--text); border-color: rgba(255,255,255,.20); }

  .toggle{ display:flex; align-items:center; justify-content:space-between; gap:12px; }
  .sw{
    width: 44px; height: 26px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,.16);
    background: rgba(255,255,255,.06);
    position:relative;
    cursor:pointer;
    flex: 0 0 auto;
    transition: background 200ms var(--ease);
  }
  .sw i{
    position:absolute; top: 3px; left: 3px;
    width: 20px; height: 20px;
    border-radius: 999px;
    background: rgba(245,250,255,.85);
    box-shadow: 0 12px 24px rgba(0,0,0,.25);
    transition: transform 220ms var(--ease), background 220ms var(--ease);
  }
  .sw.on{ background: rgba(32,210,162,.14); border-color: rgba(32,210,162,.35); }
  .sw.on i{ transform: translateX(18px); background: rgba(32,210,162,.92); }

  .hint{
    font-family: var(--mono);
    font-size: 12px;
    color: rgba(190,205,223,.60);
    padding-top: 4px;
    line-height: 1.35;
  }

  /* Canvas area */
  .stage{
    border: 1px solid var(--line);
    border-radius: var(--r);
    background: rgba(0,0,0,.14);
    box-shadow: var(--shadow);
    position: relative;
    overflow:hidden;
    min-height: 560px;
    isolation:isolate;
  }
  .stage::before{
    content:"";
    position:absolute;
    inset:-2px;
    border-radius: calc(var(--r) + 2px);
    background: conic-gradient(from 220deg,
      rgba(110,123,255,.25),
      rgba(32,210,162,.16),
      rgba(255,92,173,.14),
      rgba(110,123,255,.25));
    filter: blur(16px);
    opacity:.20;
    animation: stageSpin 14s linear infinite;
    z-index:0;
    pointer-events:none;
  }
  @keyframes stageSpin{ from{transform:rotate(0)} to{transform:rotate(360deg)} }
  @media (prefers-reduced-motion: reduce){ .stage::before{ animation:none !important; } }

  .stageInner{
    position:absolute; inset:0;
    display:grid; place-items:center;
    z-index:1;
  }
  .canWrap{
    position: relative;
    transform: translateZ(0);
    will-change: transform;
  }
  canvas{
    display:block;
    border-radius: 14px;
    background: #0b0f17;
    box-shadow: 0 26px 80px rgba(0,0,0,.55);
    touch-action: none;
  }
  #gridOverlay, #fxOverlay, #uiOverlay{
    position:absolute;
    inset:0;
    pointer-events:none;
    background: transparent;
  }

  .toast{
    position: fixed;
    right: 14px;
    bottom: 14px;
    z-index: 50;
    border: 1px solid rgba(255,255,255,.12);
    border-radius: 16px;
    background: rgba(10,14,22,.78);
    backdrop-filter: blur(12px);
    padding: 10px 12px;
    display:none;
    box-shadow: 0 20px 60px rgba(0,0,0,.45);
    min-width: min(360px, calc(100vw - 28px));
  }
  .toast.show{ display:block; animation: toastIn 220ms var(--ease) both; }
  @keyframes toastIn{ from{ transform: translateY(10px); opacity: 0; } to{ transform: translateY(0); opacity: 1; } }
  .toast .t1{ font-size: 13px; }
  .toast .t2{ margin-top: 6px; font-family: var(--mono); font-size: 12px; color: rgba(190,205,223,.70); }

  /* Tiny frame chips */
  .chips{ display:flex; flex-wrap:wrap; gap:8px; }
  .chip{
    border:1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.04);
    color: rgba(245,250,255,.86);
    padding: 7px 10px;
    border-radius: 999px;
    cursor:pointer;
    font-family: var(--mono);
    font-size: 12px;
    transition: transform 160ms var(--ease), background 160ms var(--ease), border-color 160ms var(--ease);
    user-select:none;
  }
  .chip:hover{ transform: translateY(-1px); border-color: rgba(32,210,162,.35); }
  .chip.on{
    border-color: rgba(110,123,255,.55);
    background: rgba(110,123,255,.16);
  }

  /* palette buttons */
  .pal{ display:flex; gap:8px; flex-wrap:wrap; }
  .pal button{
    width: 26px; height: 26px;
    border-radius: 10px;
    border: 1px solid rgba(255,255,255,.16);
    background: rgba(255,255,255,.04);
    cursor:pointer;
  }
</style>
</head>

<body>
  <div class="app">
    <aside class="panel" aria-label="Settings">
      <div class="pHead">
        <div class="brand">
          <div class="logo" aria-hidden="true"></div>
          <div>
            <h1 class="name" id="title">MULTICOLOR SQUARE</h1>
            <div class="mini" id="subtitle">pixel canvas — pro</div>
          </div>
        </div>
        <button class="btn ghost" id="newBtn" type="button" title="New">New</button>
      </div>

      <div class="pBody">
        <!-- core -->
        <div class="row">
          <div class="field">
            <div class="lab"><span id="labGrid">Grid</span><span id="gridVal">48</span></div>
            <input id="grid" type="range" min="16" max="160" value="48" step="1" />
          </div>
          <div class="field">
            <div class="lab"><span id="labBrush">Brush</span><span id="brushVal">1</span></div>
            <input id="brush" type="range" min="1" max="12" value="1" step="1" />
          </div>
        </div>

        <div class="row">
          <div class="field">
            <div class="lab"><span id="labColor">Color</span><span id="hexOut">#20D2A2</span></div>
            <input id="color" type="color" value="#20D2A2"/>
          </div>
          <div class="field">
            <div class="lab"><span id="labZoom">Zoom</span><span id="zoomVal">100%</span></div>
            <input id="zoom" type="range" min="60" max="220" value="100" step="1" />
          </div>
        </div>

        <!-- toggles -->
        <div class="field">
          <div class="toggle">
            <div class="lab" style="margin:0;"><span id="labRainbow">Rainbow</span><span id="rbHint"></span></div>
            <div class="sw" id="rb"><i></i></div>
          </div>
          <div class="toggle" style="margin-top:10px;">
            <div class="lab" style="margin:0;"><span id="labEraser">Eraser</span><span></span></div>
            <div class="sw" id="er"><i></i></div>
          </div>
          <div class="toggle" style="margin-top:10px;">
            <div class="lab" style="margin:0;"><span id="labGridLines">Grid lines</span><span></span></div>
            <div class="sw on" id="gl"><i></i></div>
          </div>
        </div>

        <!-- pro controls -->
        <div class="field">
          <div class="lab"><span id="labPro">Pro</span><span class="mini" id="proMini" style="letter-spacing:0;">Tools • FX • RU/EN</span></div>

          <div class="row">
            <div class="field" style="margin:0;">
              <div class="lab"><span id="labLang">Language</span><span></span></div>
              <select id="langSel">
                <option value="en">English</option>
                <option value="ru">Русский</option>
              </select>
            </div>
            <div class="field" style="margin:0;">
              <div class="lab"><span id="labTool">Tool</span><span id="toolOut">Draw</span></div>
              <select id="toolSel">
                <option value="draw">Draw</option>
                <option value="picker">Picker</option>
                <option value="fill">Fill</option>
                <option value="line">Line</option>
                <option value="rect">Rect</option>
                <option value="circle">Circle</option>
              </select>
            </div>
          </div>

          <div class="row">
            <div class="field" style="margin:0;">
              <div class="lab"><span id="labSym">Symmetry</span><span id="symOut">Off</span></div>
              <select id="symSel">
                <option value="off">Off</option>
                <option value="h">Horizontal</option>
                <option value="v">Vertical</option>
                <option value="hv">4-way</option>
              </select>
            </div>
            <div class="field" style="margin:0;">
              <div class="lab"><span id="labShape">Brush shape</span><span></span></div>
              <select id="shapeSel">
                <option value="square">Square</option>
                <option value="circle">Circle</option>
              </select>
            </div>
          </div>

          <div class="row">
            <div class="field" style="margin:0;">
              <div class="lab"><span id="labOpacity">Opacity</span><span id="opVal">100%</span></div>
              <input id="opacity" type="range" min="10" max="100" value="100" step="1" />
            </div>
            <div class="field" style="margin:0;">
              <div class="lab"><span id="labGlow">Glow</span><span id="glowVal">35</span></div>
              <input id="glow" type="range" min="0" max="90" value="35" step="1" />
            </div>
          </div>

          <div class="row">
            <div class="field" style="margin:0;">
              <div class="toggle">
                <div class="lab" style="margin:0;"><span id="labOutline">Outline</span><span id="outVal">On</span></div>
                <div class="sw on" id="ol"><i></i></div>
              </div>
              <div class="lab" style="margin-top:8px;"><span id="labOutlineA">Outline alpha</span><span id="outAVal">45</span></div>
              <input id="outA" type="range" min="0" max="100" value="45" step="1" />
            </div>
            <div class="field" style="margin:0;">
              <div class="lab"><span id="labFx">FX</span><span id="fxVal">70</span></div>
              <input id="fx" type="range" min="0" max="100" value="70" step="1" />
              <div class="toggle" style="margin-top:8px;">
                <div class="lab" style="margin:0;"><span id="labTrail">Trail</span><span></span></div>
                <div class="sw on" id="tr"><i></i></div>
              </div>
            </div>
          </div>

          <div class="row">
            <div class="field" style="margin:0;">
              <div class="lab"><span id="labBgSpeed">Background speed</span><span id="bgSpVal">1.0×</span></div>
              <input id="bgSpeed" type="range" min="40" max="180" value="100" step="1" />
            </div>
            <div class="field" style="margin:0;">
              <div class="lab"><span id="labBgHue">Background hue</span><span id="bgHueVal">206</span></div>
              <input id="bgHue" type="range" min="160" max="260" value="206" step="1" />
            </div>
          </div>

          <div class="field" style="margin:0;">
            <div class="lab"><span id="labPal">Recent colors</span><span></span></div>
            <div class="pal" id="palette"></div>
          </div>
        </div>

        <!-- animation / frames -->
        <div class="field">
          <div class="lab"><span id="labAnim">Animation</span><span class="mini" id="animMini" style="letter-spacing:0;">Frames + playback</span></div>

          <div class="row">
            <div class="field" style="margin:0;">
              <div class="lab"><span id="labFps">FPS</span><span id="fpsVal">6</span></div>
              <input id="fps" type="range" min="1" max="24" value="6" step="1" />
            </div>
            <div class="field" style="margin:0;">
              <div class="toggle">
                <div class="lab" style="margin:0;"><span id="labOnion">Onion skin</span><span></span></div>
                <div class="sw" id="onion"><i></i></div>
              </div>
              <div class="toggle" style="margin-top:10px;">
                <div class="lab" style="margin:0;"><span id="labPlay">Play</span><span></span></div>
                <div class="sw" id="play"><i></i></div>
              </div>
            </div>
          </div>

          <div class="btnRow">
            <button class="btn ghost" id="addFrame" type="button">+ Frame</button>
            <button class="btn ghost" id="dupFrame" type="button">Duplicate</button>
            <button class="btn ghost" id="delFrame" type="button">Delete</button>
          </div>

          <div class="chips" id="frameChips"></div>
        </div>

        <!-- actions -->
        <div class="btnRow">
          <button class="btn ghost" id="undoBtn" type="button">Undo</button>
          <button class="btn ghost" id="redoBtn" type="button">Redo</button>
          <button class="btn ghost" id="clearBtn" type="button">Clear</button>
          <button class="btn" id="saveBtn" type="button">Save PNG</button>
        </div>

        <div class="btnRow">
          <button class="btn ghost" id="exportBtn" type="button">Export</button>
          <button class="btn ghost" id="importBtn" type="button">Import</button>
          <button class="btn ghost" id="restoreBtn" type="button">Restore autosave</button>
          <button class="btn ghost" id="wipeAutoBtn" type="button">Wipe autosave</button>
          <input id="fileIn" type="file" accept="application/json" style="display:none;">
        </div>

        <div class="hint" id="hint">
          Draw: LMB + move • RMB: temp eraser • Mouse wheel: zoom • Shift+Wheel: faster • 1..6 tools
        </div>
      </div>
    </aside>

    <section class="stage panel" aria-label="Canvas">
      <div class="stageInner">
        <div class="canWrap" id="canWrap">
          <canvas id="paint"></canvas>
          <canvas id="gridOverlay"></canvas>
          <canvas id="fxOverlay"></canvas>
          <canvas id="uiOverlay"></canvas>
        </div>
      </div>
    </section>
  </div>

  <div class="toast" id="toast" role="status" aria-live="polite">
    <div class="t1" id="t1">OK</div>
    <div class="t2" id="t2">…</div>
  </div>

<script>
(() => {
  const $ = (s, r=document) => r.querySelector(s);
  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));

  // canvases
  const canvas = $('#paint');
  const ctx = canvas.getContext('2d', { alpha: false });
  const gridCanvas = $('#gridOverlay');
  const gctx = gridCanvas.getContext('2d');
  const fxCanvas = $('#fxOverlay');
  const fctx = fxCanvas.getContext('2d');
  const uiCanvas = $('#uiOverlay');
  const uctx = uiCanvas.getContext('2d');

  // controls
  const gridSlider = $('#grid');
  const brushSlider = $('#brush');
  const zoomSlider = $('#zoom');
  const colorPicker = $('#color');

  const opacitySlider = $('#opacity');
  const glowSlider = $('#glow');
  const outASlider = $('#outA');
  const fxSlider = $('#fx');
  const bgSpeedSlider = $('#bgSpeed');
  const bgHueSlider = $('#bgHue');

  const langSel = $('#langSel');
  const toolSel = $('#toolSel');
  const symSel = $('#symSel');
  const shapeSel = $('#shapeSel');

  const rbSw = $('#rb');
  const erSw = $('#er');
  const glSw = $('#gl');

  const olSw = $('#ol');
  const trSw = $('#tr');

  const onionSw = $('#onion');
  const playSw  = $('#play');

  const newBtn = $('#newBtn');
  const undoBtn = $('#undoBtn');
  const redoBtn = $('#redoBtn');
  const clearBtn = $('#clearBtn');
  const saveBtn = $('#saveBtn');
  const exportBtn = $('#exportBtn');
  const importBtn = $('#importBtn');
  const restoreBtn = $('#restoreBtn');
  const wipeAutoBtn = $('#wipeAutoBtn');
  const fileIn = $('#fileIn');

  const addFrameBtn = $('#addFrame');
  const dupFrameBtn = $('#dupFrame');
  const delFrameBtn = $('#delFrame');
  const chipsEl = $('#frameChips');

  const fpsSlider = $('#fps');
  const fpsVal = $('#fpsVal');

  const canWrap = $('#canWrap');

  // UI outputs
  const gridVal = $('#gridVal');
  const brushVal = $('#brushVal');
  const zoomVal = $('#zoomVal');
  const hexOut = $('#hexOut');
  const opVal = $('#opVal');
  const glowVal = $('#glowVal');
  const outVal = $('#outVal');
  const outAVal = $('#outAVal');
  const fxVal = $('#fxVal');
  const bgSpVal = $('#bgSpVal');
  const bgHueVal = $('#bgHueVal');
  const toolOut = $('#toolOut');
  const symOut = $('#symOut');
  const paletteEl = $('#palette');

  // toast
  const toastEl = $('#toast');
  const t1 = $('#t1');
  const t2 = $('#t2');
  let toastTimer = 0;
  function toast(a, b=''){
    t1.textContent = a; t2.textContent = b;
    toastEl.classList.add('show');
    clearTimeout(toastTimer);
    toastTimer = setTimeout(()=>toastEl.classList.remove('show'), 2200);
  }

  // switches helper
  function setSwitch(sw, on){ sw.classList.toggle('on', !!on); }

  // basic color helpers
  function hexToRgbInt(hex){
    const s = hex.replace('#','').trim();
    const v = parseInt(s, 16);
    return v & 0xFFFFFF;
  }
  function rgbIntToHex(v){
    return '#' + (v >>> 0).toString(16).padStart(6,'0').toUpperCase();
  }
  function hslToRgbInt(h, s, l){
    h = ((h % 360) + 360) % 360;
    const c = (1 - Math.abs(2*l - 1)) * s;
    const x = c * (1 - Math.abs(((h/60) % 2) - 1));
    const m = l - c/2;
    let r=0,g=0,b=0;
    if(h < 60){ r=c; g=x; b=0; }
    else if(h < 120){ r=x; g=c; b=0; }
    else if(h < 180){ r=0; g=c; b=x; }
    else if(h < 240){ r=0; g=x; b=c; }
    else if(h < 300){ r=x; g=0; b=c; }
    else { r=c; g=0; b=x; }
    const R = Math.round((r+m)*255);
    const G = Math.round((g+m)*255);
    const B = Math.round((b+m)*255);
    return (R<<16) | (G<<8) | B;
  }

  // persistence keys
  const LS_KEY = 'mcs_pro_autosave_v3';
  const LS_LANG = 'mcs_lang_v1';

  // state
  let N = +gridSlider.value;
  let brush = +brushSlider.value;
  let zoom = +zoomSlider.value / 100;

  let showGrid = true;
  let rainbow = false;
  let eraser = false;

  let opacity = +opacitySlider.value / 100;
  let glow = +glowSlider.value;
  let outlineOn = true;
  let outlineA = +outASlider.value / 100;
  let fxIntensity = +fxSlider.value / 100;
  let trailOn = true;

  let tool = 'draw';        // draw|picker|fill|line|rect|circle
  let sym = 'off';          // off|h|v|hv
  let brushShape = 'square';

  const BG = 0x0b0f17;

  // frames system
  function makeFrame(){
    return {
      pixels: new Uint32Array(N*N),
      undo: [],
      redo: [],
    };
  }
  let frames = [makeFrame()];
  let fi = 0; // current frame index
  frames[0].pixels.fill(BG);

  // drawing stroke state
  let drawing = false;
  let lastCell = null; // {x,y}
  let currentAction = null;
  let lineStart = null;

  // RMB temp eraser
  let rmbTemp = false;
  let prevEraser = false;

  // animation playback
  let playing = false;
  let onion = false;
  let fps = +fpsSlider.value;
  let playAcc = 0;
  let lastT = performance.now();

  // recent colors
  const recent = [];
  function addRecent(hex){
    const h = hex.toUpperCase();
    const i = recent.indexOf(h);
    if(i !== -1) recent.splice(i,1);
    recent.unshift(h);
    if(recent.length > 14) recent.length = 14;
    renderPalette();
  }
  function renderPalette(){
    paletteEl.innerHTML = '';
    for(const h of recent){
      const b = document.createElement('button');
      b.type = 'button';
      b.style.background = h;
      b.title = h;
      b.addEventListener('click', () => {
        colorPicker.value = h;
        hexOut.textContent = h;
        if(eraser){ eraser=false; setSwitch(erSw, eraser); }
        toast('Color', h);
      });
      paletteEl.appendChild(b);
    }
  }

  // i18n
  const T = {
    en: {
      subtitle:'pixel canvas — pro',
      labGrid:'Grid', labBrush:'Brush', labColor:'Color', labZoom:'Zoom',
      labRainbow:'Rainbow', labEraser:'Eraser', labGridLines:'Grid lines',
      pro:'Pro', proMini:'Tools • FX • RU/EN',
      lang:'Language', tool:'Tool', sym:'Symmetry', shape:'Brush shape',
      opacity:'Opacity', glow:'Glow', outline:'Outline', outlineA:'Outline alpha', fx:'FX', trail:'Trail',
      bgSpeed:'Background speed', bgHue:'Background hue', pal:'Recent colors',
      anim:'Animation', animMini:'Frames + playback', fps:'FPS', onion:'Onion skin', play:'Play',
      addF:'+ Frame', dup:'Duplicate', del:'Delete',
      new:'New', undo:'Undo', redo:'Redo', clear:'Clear', save:'Save PNG', export:'Export', import:'Import', restore:'Restore autosave', wipe:'Wipe autosave',
      hint:'Draw: LMB + move • RMB: temp eraser • Mouse wheel: zoom • Shift+Wheel: faster • 1..6 tools',
      tools: {draw:'Draw', picker:'Picker', fill:'Fill', line:'Line', rect:'Rect', circle:'Circle'},
      symMap: {off:'Off', h:'Horizontal', v:'Vertical', hv:'4-way'},
      shapeMap: {square:'Square', circle:'Circle'},
      on:'On', off:'Off'
    },
    ru: {
      subtitle:'пиксель‑канвас — про',
      labGrid:'Сетка', labBrush:'Кисть', labColor:'Цвет', labZoom:'Зум',
      labRainbow:'Радуга', labEraser:'Ластик', labGridLines:'Линии сетки',
      pro:'ПРО', proMini:'Инструменты • FX • RU/EN',
      lang:'Язык', tool:'Инструмент', sym:'Симметрия', shape:'Форма кисти',
      opacity:'Непрозрач.', glow:'Свечение', outline:'Обводка', outlineA:'Обводка альфа', fx:'Эффекты', trail:'Шлейф',
      bgSpeed:'Скорость фона', bgHue:'Оттенок фона', pal:'Недавние цвета',
      anim:'Анимация', animMini:'Кадры + проигрывание', fps:'FPS', onion:'Луковица', play:'Пуск',
      addF:'+ Кадр', dup:'Дубликат', del:'Удалить',
      new:'Новый', undo:'Отмена', redo:'Повтор', clear:'Очистить', save:'PNG', export:'Экспорт', import:'Импорт', restore:'Восстановить', wipe:'Стереть автосейв',
      hint:'Рисуй: ЛКМ + движение • ПКМ: временный ластик • Колесо: зум • Shift+Колесо: быстрее • 1..6 инструменты',
      tools: {draw:'Рисование', picker:'Пипетка', fill:'Заливка', line:'Линия', rect:'Прямоуг.', circle:'Круг'},
      symMap: {off:'Выкл', h:'Гориз.', v:'Вертик.', hv:'4‑стор.'},
      shapeMap: {square:'Квадрат', circle:'Круг'},
      on:'Вкл', off:'Выкл'
    }
  };
  function tr(){ return T[langSel.value] || T.en; }
  function applyLang(){
    const t = tr();
    $('#subtitle').textContent = t.subtitle;

    $('#labGrid').textContent = t.labGrid;
    $('#labBrush').textContent = t.labBrush;
    $('#labColor').textContent = t.labColor;
    $('#labZoom').textContent = t.labZoom;

    $('#labRainbow').textContent = t.labRainbow;
    $('#labEraser').textContent = t.labEraser;
    $('#labGridLines').textContent = t.labGridLines;

    $('#labPro').textContent = t.pro;
    $('#proMini').textContent = t.proMini;
    $('#labLang').textContent = t.lang;
    $('#labTool').textContent = t.tool;
    $('#labSym').textContent = t.sym;
    $('#labShape').textContent = t.shape;
    $('#labOpacity').textContent = t.opacity;
    $('#labGlow').textContent = t.glow;
    $('#labOutline').textContent = t.outline;
    $('#labOutlineA').textContent = t.outlineA;
    $('#labFx').textContent = t.fx;
    $('#labTrail').textContent = t.trail;
    $('#labBgSpeed').textContent = t.bgSpeed;
    $('#labBgHue').textContent = t.bgHue;
    $('#labPal').textContent = t.pal;

    $('#labAnim').textContent = t.anim;
    $('#animMini').textContent = t.animMini;
    $('#labFps').textContent = t.fps;
    $('#labOnion').textContent = t.onion;
    $('#labPlay').textContent = t.play;

    addFrameBtn.textContent = t.addF;
    dupFrameBtn.textContent = t.dup;
    delFrameBtn.textContent = t.del;

    newBtn.textContent = t.new;
    undoBtn.textContent = t.undo;
    redoBtn.textContent = t.redo;
    clearBtn.textContent = t.clear;
    saveBtn.textContent = t.save;
    exportBtn.textContent = t.export;
    importBtn.textContent = t.import;
    restoreBtn.textContent = t.restore;
    wipeAutoBtn.textContent = t.wipe;

    $('#hint').textContent = t.hint;

    // tool options
    [...toolSel.options].forEach(o => o.textContent = t.tools[o.value] || o.value);
    toolOut.textContent = t.tools[tool] || tool;

    // sym options
    [...symSel.options].forEach(o => o.textContent = t.symMap[o.value] || o.value);
    symOut.textContent = t.symMap[sym] || sym;

    // shape options
    [...shapeSel.options].forEach(o => o.textContent = t.shapeMap[o.value] || o.value);

    outVal.textContent = outlineOn ? t.on : t.off;

    try{ localStorage.setItem(LS_LANG, langSel.value); }catch(e){}
  }
  (function initLang(){
    try{
      const saved = localStorage.getItem(LS_LANG);
      if(saved && (saved==='en' || saved==='ru')) langSel.value = saved;
    }catch(e){}
    applyLang();
  })();
  langSel.addEventListener('change', applyLang);

  // background controls
  function setBgSpeed(v){
    const k = v/100;
    document.documentElement.style.setProperty('--bgSpeed', String(k.toFixed(3)));
    bgSpVal.textContent = k.toFixed(1) + '×';
  }
  function setBgHue(v){
    document.documentElement.style.setProperty('--bgHue', String(v|0));
    bgHueVal.textContent = String(v|0);
  }
  bgSpeedSlider.addEventListener('input', ()=> setBgSpeed(+bgSpeedSlider.value));
  bgHueSlider.addEventListener('input', ()=> setBgHue(+bgHueSlider.value));
  setBgSpeed(+bgSpeedSlider.value);
  setBgHue(+bgHueSlider.value);

  // parallax vars
  window.addEventListener('pointermove', (e) => {
    const x = e.clientX / Math.max(1, innerWidth);
    const y = e.clientY / Math.max(1, innerHeight);
    document.documentElement.style.setProperty('--mx', String(x.toFixed(4)));
    document.documentElement.style.setProperty('--my', String(y.toFixed(4)));
  });

  // UI updates
  function updateUI(){
    gridVal.textContent = String(N);
    brushVal.textContent = String(brush);
    zoomVal.textContent = Math.round(zoom*100) + '%';
    hexOut.textContent = colorPicker.value.toUpperCase();
    opVal.textContent = Math.round(opacity*100) + '%';
    glowVal.textContent = String(glow);
    outAVal.textContent = String(Math.round(outlineA*100));
    fxVal.textContent = String(Math.round(fxIntensity*100));
    toolOut.textContent = (tr().tools[tool] || tool);
    symOut.textContent = (tr().symMap[sym] || sym);

    setSwitch(rbSw, rainbow);
    setSwitch(erSw, eraser);
    setSwitch(glSw, showGrid);
    setSwitch(olSw, outlineOn);
    setSwitch(trSw, trailOn);
    setSwitch(onionSw, onion);
    setSwitch(playSw, playing);
  }

  function calcCanvasSize(){
    const stage = document.querySelector('.stage');
    const r = stage.getBoundingClientRect();
    const pad = 26;
    const size = Math.max(300, Math.min(r.width - pad, r.height - pad));
    return Math.floor(size);
  }

  function setupCanvases(){
    const size = calcCanvasSize();
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

    const w = Math.floor(size * dpr);
    const h = Math.floor(size * dpr);

    for(const c of [canvas, gridCanvas, fxCanvas, uiCanvas]){
      c.width = w; c.height = h;
      c.style.width = size + 'px';
      c.style.height = size + 'px';
    }

    ctx.setTransform(dpr,0,0,dpr,0,0);
    gctx.setTransform(dpr,0,0,dpr,0,0);
    fctx.setTransform(dpr,0,0,dpr,0,0);
    uctx.setTransform(dpr,0,0,dpr,0,0);

    canWrap.style.transform = `scale(${zoom})`;
    drawAll();
    drawGrid();
  }

  function drawGrid(){
    const size = parseFloat(gridCanvas.style.width) || 600;
    const cs = size / N;

    gctx.clearRect(0,0,size,size);
    if(!showGrid) return;

    gctx.globalAlpha = 0.50;
    gctx.lineWidth = 1;
    gctx.strokeStyle = 'rgba(255,255,255,.10)';

    let step = 1;
    if(N >= 96) step = 2;
    if(N >= 128) step = 4;

    gctx.beginPath();
    for(let i=0;i<=N;i+=step){
      const p = i*cs;
      gctx.moveTo(p, 0); gctx.lineTo(p, size);
      gctx.moveTo(0, p); gctx.lineTo(size, p);
    }
    gctx.stroke();
    gctx.globalAlpha = 1;
  }

  function drawFramePixels(pix, alpha=1, tint=null){
    const size = parseFloat(canvas.style.width) || 600;
    const cs = size / N;
    ctx.save();
    ctx.globalAlpha = alpha;

    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        const idx = y*N + x;
        let col = pix[idx]>>>0;
        if(col === (BG>>>0)) continue;
        if(tint){
          // tint is [r,g,b] 0..1 multiplier
          const r = ((col>>16)&255) * tint[0];
          const g = ((col>>8)&255)  * tint[1];
          const b = (col&255)       * tint[2];
          col = ((r|0)<<16) | ((g|0)<<8) | (b|0);
        }
        ctx.fillStyle = '#' + col.toString(16).padStart(6,'0');
        ctx.fillRect(x*cs, y*cs, cs, cs);
      }
    }
    ctx.restore();
  }

  function drawOutline(pix){
    if(!outlineOn || outlineA <= 0) return;
    const size = parseFloat(canvas.style.width) || 600;
    const cs = size / N;
    ctx.save();
    ctx.globalAlpha = outlineA;
    ctx.lineWidth = 1;
    ctx.strokeStyle = 'rgba(0,0,0,.70)';
    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        const idx = y*N + x;
        const col = pix[idx]>>>0;
        if(col === (BG>>>0)) continue;
        ctx.strokeRect(x*cs+0.5, y*cs+0.5, cs-1, cs-1);
      }
    }
    ctx.restore();
  }

  function drawAll(){
    const size = parseFloat(canvas.style.width) || 600;

    // base
    ctx.fillStyle = '#' + (BG>>>0).toString(16).padStart(6,'0');
    ctx.fillRect(0,0,size,size);

    // onion skin (prev/next)
    if(onion && frames.length > 1){
      const prev = frames[(fi - 1 + frames.length) % frames.length].pixels;
      const next = frames[(fi + 1) % frames.length].pixels;
      drawFramePixels(prev, 0.25, [0.7,0.85,1.0]);
      drawFramePixels(next, 0.20, [1.0,0.75,0.92]);
    }

    // current
    drawFramePixels(frames[fi].pixels, 1);

    // outline
    drawOutline(frames[fi].pixels);
  }

  function posToCell(e){
    const rect = canvas.getBoundingClientRect();
    const size = rect.width;
    const cs = size / N;
    const x = Math.floor((e.clientX - rect.left) / cs);
    const y = Math.floor((e.clientY - rect.top) / cs);
    return { x, y };
  }

  function beginStroke(){
    currentAction = { idxs:[], prev:[], next:[], seen: new Set() };
  }
  function endStroke(){
    if(!currentAction) return;
    if(currentAction.idxs.length){
      const f = frames[fi];
      f.undo.push({ idxs: currentAction.idxs, prev: currentAction.prev, next: currentAction.next });
      if(f.undo.length > 70) f.undo.shift();
      f.redo.length = 0;
      saveAuto();
    }
    currentAction = null;
  }

  function paintCell(x, y, col){
    if(x < 0 || y < 0 || x >= N || y >= N) return;
    const idx = y*N + x;

    const f = frames[fi];
    const prev = f.pixels[idx]>>>0;
    col = col>>>0;
    if(prev === col) return;

    if(currentAction){
      if(!currentAction.seen.has(idx)){
        currentAction.seen.add(idx);
        currentAction.idxs.push(idx);
        currentAction.prev.push(prev);
        currentAction.next.push(col);
      }
    }
    f.pixels[idx] = col;

    // live draw cell
    const size = parseFloat(canvas.style.width) || 600;
    const cs = size / N;

    ctx.save();
    ctx.globalAlpha = 1;

    // fill base
    ctx.fillStyle = '#' + col.toString(16).padStart(6,'0');
    ctx.fillRect(x*cs, y*cs, cs, cs);

    // glow overlay
    if(glow > 0 && col !== (BG>>>0)){
      ctx.globalAlpha = 0.20 * opacity;
      ctx.shadowColor = '#' + col.toString(16).padStart(6,'0');
      ctx.shadowBlur = glow;
      ctx.fillStyle = 'rgba(255,255,255,.15)';
      ctx.fillRect(x*cs, y*cs, cs, cs);
    }

    // outline per cell
    if(outlineOn && outlineA > 0){
      ctx.globalAlpha = outlineA;
      ctx.shadowBlur = 0;
      ctx.strokeStyle = 'rgba(0,0,0,.70)';
      ctx.lineWidth = 1;
      ctx.strokeRect(x*cs+0.5, y*cs+0.5, cs-1, cs-1);
    }

    ctx.restore();
  }

  function brushColorForCell(x,y){
    if(eraser) return BG;
    if(!rainbow) return hexToRgbInt(colorPicker.value);

    const t = performance.now() * 0.001;
    const hue = (t*90 + (x*9) + (y*7)) % 360;
    return hslToRgbInt(hue, 1.0, 0.55);
  }

  function applySymPoints(cx,cy, fn){
    const pts = [[cx,cy]];
    const mx = (N - 1) - cx;
    const my = (N - 1) - cy;

    if(sym === 'h' || sym === 'hv') pts.push([mx, cy]);
    if(sym === 'v' || sym === 'hv') pts.push([cx, my]);
    if(sym === 'hv') pts.push([mx, my]);

    const uniq = new Set();
    for(const [x,y] of pts){
      const k = x + ',' + y;
      if(uniq.has(k)) continue;
      uniq.add(k);
      fn(x,y);
    }
  }

  function paintBrush(cx, cy){
    const half = Math.floor(brush / 2);
    const r = brush / 2;

    applySymPoints(cx,cy,(sx,sy)=>{
      for(let dy=-half; dy< -half+brush; dy++){
        for(let dx=-half; dx< -half+brush; dx++){
          if(brushShape === 'circle'){
            const px = dx + 0.5, py = dy + 0.5;
            if((px*px + py*py) > r*r) continue;
          }
          const x = sx + dx;
          const y = sy + dy;
          const col = brushColorForCell(x,y);
          if(opacity < 1 && col !== (BG>>>0)){
            // pseudo alpha: blend with existing pixel
            const idx = y*N + x;
            if(x<0||y<0||x>=N||y>=N) continue;
            const base = frames[fi].pixels[idx]>>>0;
            const br = (base>>16)&255, bg=(base>>8)&255, bb=base&255;
            const nr = (col>>16)&255,  ng=(col>>8)&255,  nb=col&255;
            const rr = (br + (nr-br)*opacity)|0;
            const gg = (bg + (ng-bg)*opacity)|0;
            const bb2= (bb + (nb-bb)*opacity)|0;
            paintCell(x,y, (rr<<16)|(gg<<8)|bb2 );
          }else{
            paintCell(x,y,col);
          }
          fxBurst(x,y,col);
        }
      }
    });
  }

  // flood fill
  function floodFill(x,y){
    if(x<0||y<0||x>=N||y>=N) return;
    const f = frames[fi];
    const target = f.pixels[y*N+x]>>>0;
    const repl = eraser ? (BG>>>0) : (hexToRgbInt(colorPicker.value)>>>0);
    if(target === repl) return;

    beginStroke();
    const st = [x,y];
    const seen = new Uint8Array(N*N);

    while(st.length){
      const cy = st.pop();
      const cx = st.pop();
      if(cx<0||cy<0||cx>=N||cy>=N) continue;
      const idx = cy*N + cx;
      if(seen[idx]) continue;
      seen[idx] = 1;
      if((f.pixels[idx]>>>0) !== target) continue;

      paintCell(cx,cy,repl);

      st.push(cx+1,cy); st.push(cx-1,cy); st.push(cx,cy+1); st.push(cx,cy-1);
    }
    endStroke();
    drawAll();
    toast(tr().tools.fill, 'OK');
  }

  function pickAtCell(x,y){
    if(x<0||y<0||x>=N||y>=N) return;
    const col = frames[fi].pixels[y*N+x]>>>0;
    if(col === (BG>>>0)) return;
    const hex = rgbIntToHex(col);
    colorPicker.value = hex;
    hexOut.textContent = hex;
    addRecent(hex);
    if(eraser){ eraser=false; setSwitch(erSw, eraser); }
    toast(tr().tools.picker, hex);
  }

  // geometry tools
  function drawLine(x0,y0,x1,y1){
    let dx = Math.abs(x1-x0), sx = x0<x1 ? 1 : -1;
    let dy = -Math.abs(y1-y0), sy = y0<y1 ? 1 : -1;
    let err = dx + dy;
    while(true){
      paintBrush(x0,y0);
      if(x0===x1 && y0===y1) break;
      const e2 = 2*err;
      if(e2 >= dy){ err += dy; x0 += sx; }
      if(e2 <= dx){ err += dx; y0 += sy; }
    }
  }
  function drawRect(x0,y0,x1,y1, fill){
    const minX = Math.min(x0,x1), maxX = Math.max(x0,x1);
    const minY = Math.min(y0,y1), maxY = Math.max(y0,y1);
    if(fill){
      for(let y=minY;y<=maxY;y++) for(let x=minX;x<=maxX;x++) paintBrush(x,y);
    }else{
      for(let x=minX;x<=maxX;x++){ paintBrush(x,minY); paintBrush(x,maxY); }
      for(let y=minY;y<=maxY;y++){ paintBrush(minX,y); paintBrush(maxX,y); }
    }
  }
  function drawCircle(cx,cy, r, fill){
    const rr = r*r;
    for(let y=cy-r; y<=cy+r; y++){
      for(let x=cx-r; x<=cx+r; x++){
        const dx=x-cx, dy=y-cy;
        const d = dx*dx + dy*dy;
        if(fill){
          if(d <= rr) paintBrush(x,y);
        }else{
          if(d <= rr && d >= (rr - Math.max(2, r))) paintBrush(x,y);
        }
      }
    }
  }

  // Undo/redo per frame
  function doUndo(){
    const f = frames[fi];
    const a = f.undo.pop();
    if(!a) return;
    for(let i=0;i<a.idxs.length;i++) f.pixels[a.idxs[i]] = a.prev[i];
    f.redo.push(a);
    drawAll();
    toast(tr().undo, `${a.idxs.length}`);
    saveAuto();
  }
  function doRedo(){
    const f = frames[fi];
    const a = f.redo.pop();
    if(!a) return;
    for(let i=0;i<a.idxs.length;i++) f.pixels[a.idxs[i]] = a.next[i];
    f.undo.push(a);
    drawAll();
    toast(tr().redo, `${a.idxs.length}`);
    saveAuto();
  }

  function clearAll(){
    if(!confirm(langSel.value==='ru' ? 'Очистить кадр?' : 'Clear frame?')) return;
    const f = frames[fi];
    beginStroke();
    for(let i=0;i<f.pixels.length;i++){
      if(f.pixels[i] !== (BG>>>0)){
        currentAction.seen.add(i);
        currentAction.idxs.push(i);
        currentAction.prev.push(f.pixels[i]>>>0);
        currentAction.next.push(BG>>>0);
      }
      f.pixels[i] = BG>>>0;
    }
    endStroke();
    drawAll();
    toast(tr().clear, 'OK');
  }

  function newProject(){
    if(!confirm(langSel.value==='ru' ? 'Новый проект? (всё сбросится)' : 'New project? (reset everything)')) return;
    frames = [makeFrame()];
    frames[0].pixels.fill(BG);
    fi = 0;
    lineStart = null;
    rebuildChips();
    drawAll();
    drawGrid();
    saveAuto();
    toast(tr().new, `${N}×${N}`);
  }

  // save PNG (current frame)
  function savePNG(){
    const cellPx = 20;
    const outSize = N * cellPx;
    const off = document.createElement('canvas');
    off.width = outSize;
    off.height = outSize;
    const o = off.getContext('2d', { alpha: false });

    o.fillStyle = '#' + (BG>>>0).toString(16).padStart(6,'0');
    o.fillRect(0,0,outSize,outSize);

    const pix = frames[fi].pixels;
    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        const idx = y*N + x;
        const col = pix[idx]>>>0;
        if(col === (BG>>>0)) continue;
        o.fillStyle = '#' + col.toString(16).padStart(6,'0');
        o.fillRect(x*cellPx, y*cellPx, cellPx, cellPx);
      }
    }

    const url = off.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = url;
    a.download = `mcs_frame${fi+1}_${N}x${N}.png`;
    a.click();
    toast('Saved', a.download);
  }

  // export/import (project)
  function exportJSON(){
    const payload = {
      app:'Multicolor Square Pro',
      v: 3,
      N,
      BG,
      settings: {
        rainbow, showGrid, glow, outlineOn, outlineA, fxIntensity, trailOn, opacity, sym, brushShape
      },
      frames: frames.map(f => Array.from(f.pixels))
    };
    const blob = new Blob([JSON.stringify(payload)], { type:'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `mcs_pro_${N}x${N}_${payload.frames.length}f.json`;
    a.click();
    URL.revokeObjectURL(url);
    toast('Export', a.download);
  }

  async function importJSONFile(file){
    try{
      const text = await file.text();
      const data = JSON.parse(text);
      if(!data || !data.app || !Array.isArray(data.frames) || !Number.isFinite(data.N)){
        toast('Import', 'Invalid');
        return;
      }
      N = clamp(data.N|0, 16, 160);
      gridSlider.value = String(N);

      frames = data.frames.map(arr=>{
        const f = makeFrame();
        const pix = f.pixels;
        for(let i=0;i<pix.length;i++) pix[i] = ((arr[i]>>>0) & 0xFFFFFF) || (BG>>>0);
        return f;
      });
      if(!frames.length){
        frames = [makeFrame()];
        frames[0].pixels.fill(BG);
      }
      fi = 0;

      // settings
      const s = data.settings || {};
      rainbow = !!s.rainbow;
      showGrid = s.showGrid !== false;
      glow = clamp(+s.glow || glow, 0, 90);
      outlineOn = s.outlineOn !== false;
      outlineA = clamp(+s.outlineA || outlineA, 0, 1);
      fxIntensity = clamp(+s.fxIntensity || fxIntensity, 0, 1);
      trailOn = s.trailOn !== false;
      opacity = clamp(+s.opacity || opacity, 0.1, 1);
      sym = s.sym || sym;
      brushShape = s.brushShape || brushShape;

      glowSlider.value = String(glow);
      outASlider.value = String(Math.round(outlineA*100));
      fxSlider.value = String(Math.round(fxIntensity*100));
      opacitySlider.value = String(Math.round(opacity*100));
      symSel.value = sym;
      shapeSel.value = brushShape;

      rebuildChips();
      updateUI();
      setupCanvases();
      drawGrid();
      saveAuto();
      toast('Import', `${N}×${N}`);
    }catch(e){
      toast('Import', 'Error');
    }
  }

  // autosave
  function makeAutosave(){
    return {
      app:'Multicolor Square Pro',
      v:3,
      N,
      BG,
      fi,
      settings: {
        rainbow, showGrid, glow, outlineOn, outlineA, fxIntensity, trailOn, opacity, sym, brushShape,
        bgSpeed: +bgSpeedSlider.value,
        bgHue: +bgHueSlider.value,
        lang: langSel.value
      },
      fps,
      onion,
      frames: frames.map(f => Array.from(f.pixels))
    };
  }
  function saveAuto(){
    try{ localStorage.setItem(LS_KEY, JSON.stringify(makeAutosave())); }catch(e){}
  }
  function loadAuto(){
    try{
      const t = localStorage.getItem(LS_KEY);
      if(!t) return false;
      const data = JSON.parse(t);
      if(!data || data.app !== 'Multicolor Square Pro' || !Array.isArray(data.frames) || !Number.isFinite(data.N)) return false;

      N = clamp(data.N|0, 16, 160);
      gridSlider.value = String(N);

      // restore frames
      frames = data.frames.map(arr=>{
        const f = makeFrame();
        const pix = f.pixels;
        for(let i=0;i<pix.length;i++) pix[i] = ((arr[i]>>>0) & 0xFFFFFF) || (BG>>>0);
        return f;
      });
      if(!frames.length){ frames=[makeFrame()]; frames[0].pixels.fill(BG); }

      fi = clamp(data.fi|0, 0, frames.length-1);

      const s = data.settings || {};
      rainbow = !!s.rainbow;
      showGrid = s.showGrid !== false;
      glow = clamp(+s.glow || glow, 0, 90);
      outlineOn = s.outlineOn !== false;
      outlineA = clamp(+s.outlineA || outlineA, 0, 1);
      fxIntensity = clamp(+s.fxIntensity || fxIntensity, 0, 1);
      trailOn = s.trailOn !== false;
      opacity = clamp(+s.opacity || opacity, 0.1, 1);
      sym = s.sym || sym;
      brushShape = s.brushShape || brushShape;

      fps = clamp(data.fps|0 || fps, 1, 24);
      onion = !!data.onion;

      if(s.lang && (s.lang==='en' || s.lang==='ru')) langSel.value = s.lang;
      applyLang();

      if(Number.isFinite(+s.bgSpeed)) bgSpeedSlider.value = String(clamp(+s.bgSpeed, 40, 180));
      if(Number.isFinite(+s.bgHue)) bgHueSlider.value = String(clamp(+s.bgHue, 160, 260));
      setBgSpeed(+bgSpeedSlider.value);
      setBgHue(+bgHueSlider.value);

      glowSlider.value = String(glow);
      outASlider.value = String(Math.round(outlineA*100));
      fxSlider.value = String(Math.round(fxIntensity*100));
      opacitySlider.value = String(Math.round(opacity*100));
      symSel.value = sym;
      shapeSel.value = brushShape;

      fpsSlider.value = String(fps);
      fpsVal.textContent = String(fps);

      setSwitch(onionSw, onion);

      rebuildChips();
      updateUI();
      setupCanvases();
      drawGrid();
      toast('Restored', `${frames.length} frames`);
      return true;
    }catch(e){
      return false;
    }
  }
  function wipeAuto(){
    try{ localStorage.removeItem(LS_KEY); toast('Autosave','Removed'); }catch(e){ toast('Autosave','Error'); }
  }

  // FX system (particles + ripples + trail)
  const particles = [];
  const ripples = [];
  let lastFxFade = performance.now();

  function fxBurst(x,y,col){
    if(fxIntensity <= 0) return;

    const sizeCss = parseFloat(fxCanvas.style.width) || 600;
    const cs = sizeCss / N;
    const cx = (x + 0.5) * cs;
    const cy = (y + 0.5) * cs;

    const hex = '#' + (col>>>0).toString(16).padStart(6,'0');
    const n = Math.max(1, (3 + (fxIntensity*10)|0));

    for(let i=0;i<n;i++){
      particles.push({
        x: cx, y: cy,
        vx: (Math.random()-.5)*(1.1 + fxIntensity*2.0),
        vy: (Math.random()-.5)*(1.1 + fxIntensity*2.0),
        life: 1,
        r: 1.6 + Math.random()*3.4,
        c: hex
      });
    }
    if(Math.random() < 0.22 * fxIntensity){
      ripples.push({ x:cx, y:cy, r: 2, life: 1, c: hex });
    }
  }

  function fxTick(now){
    const w = parseFloat(fxCanvas.style.width) || 600;
    const h = w;

    // trail fade
    if(!trailOn){
      fctx.clearRect(0,0,w,h);
    }else{
      const dt = Math.min(0.05, (now-lastFxFade)/1000);
      lastFxFade = now;
      fctx.save();
      fctx.globalCompositeOperation = 'source-over';
      fctx.globalAlpha = 0.14 + (1 - fxIntensity)*0.10;
      fctx.fillStyle = 'rgba(0,0,0,1)';
      fctx.fillRect(0,0,w,h);
      fctx.restore();
    }

    // additive
    fctx.globalCompositeOperation = 'lighter';

    for(let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.life *= 0.88;
      p.x += p.vx; p.y += p.vy;
      p.vx *= 0.92; p.vy *= 0.92;

      if(p.life < 0.05){ particles.splice(i,1); continue; }

      fctx.save();
      fctx.globalAlpha = Math.min(0.55, p.life) * (0.35 + fxIntensity*0.9);
      fctx.shadowColor = p.c;
      fctx.shadowBlur = 18 + fxIntensity*26;
      fctx.fillStyle = p.c;
      fctx.beginPath();
      fctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      fctx.fill();
      fctx.restore();
    }

    for(let i=ripples.length-1;i>=0;i--){
      const r = ripples[i];
      r.life *= 0.92;
      r.r += 1.2 + fxIntensity*2.2;
      if(r.life < 0.05){ ripples.splice(i,1); continue; }

      fctx.save();
      fctx.globalAlpha = r.life * (0.22 + fxIntensity*0.35);
      fctx.strokeStyle = r.c;
      fctx.lineWidth = 2;
      fctx.shadowColor = r.c;
      fctx.shadowBlur = 18;
      fctx.beginPath();
      fctx.arc(r.x, r.y, r.r, 0, Math.PI*2);
      fctx.stroke();
      fctx.restore();
    }

    fctx.globalCompositeOperation = 'source-over';
    requestAnimationFrame(fxTick);
  }

  // UI overlay (crosshair + coords + tool preview)
  function uiTick(){
    const w = parseFloat(uiCanvas.style.width) || 600;
    const h = w;
    uctx.clearRect(0,0,w,h);

    // preview of pending shape start
    if(lineStart){
      const sizeCss = parseFloat(canvas.style.width) || 600;
      const cs = sizeCss / N;
      const px = (lineStart.x + 0.5)*cs;
      const py = (lineStart.y + 0.5)*cs;

      uctx.save();
      uctx.globalAlpha = 0.65;
      uctx.strokeStyle = 'rgba(255,255,255,.55)';
      uctx.lineWidth = 1;
      uctx.setLineDash([6,6]);
      uctx.beginPath();
      uctx.arc(px, py, 10, 0, Math.PI*2);
      uctx.stroke();
      uctx.restore();
    }

    requestAnimationFrame(uiTick);
  }

  // frames UI
  function rebuildChips(){
    chipsEl.innerHTML = '';
    frames.forEach((_,i)=>{
      const b = document.createElement('div');
      b.className = 'chip' + (i===fi ? ' on' : '');
      b.textContent = (i+1);
      b.addEventListener('click', ()=>{
        fi = i;
        lineStart = null;
        rebuildChips();
        drawAll();
        saveAuto();
      });
      chipsEl.appendChild(b);
    });
  }

  function addFrame(){
    if(frames.length >= 24){ toast('Frames','Max 24'); return; }
    const f = makeFrame();
    f.pixels.set(frames[fi].pixels); // start from current
    frames.splice(fi+1, 0, f);
    fi = fi+1;
    rebuildChips();
    drawAll();
    saveAuto();
    toast('Frame', `#${fi+1}`);
  }
  function dupFrame(){
    if(frames.length >= 24){ toast('Frames','Max 24'); return; }
    const f = makeFrame();
    f.pixels.set(frames[fi].pixels);
    frames.splice(fi+1, 0, f);
    fi++;
    rebuildChips();
    drawAll();
    saveAuto();
    toast('Duplicate', `#${fi+1}`);
  }
  function delFrame(){
    if(frames.length <= 1){ toast('Frame','Min 1'); return; }
    if(!confirm(langSel.value==='ru' ? 'Удалить кадр?' : 'Delete frame?')) return;
    frames.splice(fi,1);
    fi = clamp(fi, 0, frames.length-1);
    rebuildChips();
    drawAll();
    saveAuto();
    toast('Delete', `#${fi+1}`);
  }

  // zoom by wheel over stage
  const stageEl = document.querySelector('.stage');
  stageEl.addEventListener('wheel', (e) => {
    e.preventDefault();
    const fast = e.shiftKey ? 7 : 3;
    const dir = Math.sign(e.deltaY);
    const next = clamp(+zoomSlider.value + (-dir * fast), +zoomSlider.min, +zoomSlider.max);
    zoomSlider.value = String(next);
    zoomSlider.dispatchEvent(new Event('input', { bubbles:true }));
  }, { passive:false });

  // controls binding
  gridSlider.addEventListener('input', () => { N = +gridSlider.value; updateUI(); });
  gridSlider.addEventListener('change', () => {
    // resizing resets project (simple + safe)
    if(!confirm(langSel.value==='ru' ? 'Изменить сетку? Проект сбросится.' : 'Change grid? Project will reset.')) {
      // revert
      gridSlider.value = String(N);
      return;
    }
    N = +gridSlider.value;

    frames = [makeFrame()];
    frames[0].pixels.fill(BG);
    fi = 0;

    rebuildChips();
    updateUI();
    setupCanvases();
    drawGrid();
    saveAuto();
    toast('Grid', `${N}×${N}`);
  });

  brushSlider.addEventListener('input', () => { brush = +brushSlider.value; updateUI(); });

  zoomSlider.addEventListener('input', () => {
    zoom = +zoomSlider.value / 100;
    updateUI();
    canWrap.style.transform = `scale(${zoom})`;
  });

  colorPicker.addEventListener('input', () => {
    hexOut.textContent = colorPicker.value.toUpperCase();
    addRecent(colorPicker.value);
    if(eraser){ eraser=false; setSwitch(erSw, eraser); }
  });

  opacitySlider.addEventListener('input', ()=>{ opacity = +opacitySlider.value/100; updateUI(); });
  glowSlider.addEventListener('input', ()=>{ glow = +glowSlider.value; updateUI(); });
  outASlider.addEventListener('input', ()=>{ outlineA = +outASlider.value/100; updateUI(); drawAll(); });
  fxSlider.addEventListener('input', ()=>{ fxIntensity = +fxSlider.value/100; updateUI(); });
  shapeSel.addEventListener('change', ()=>{ brushShape = shapeSel.value; toast('Shape', brushShape); });

  toolSel.addEventListener('change', ()=>{ tool = toolSel.value; toolOut.textContent = tr().tools[tool] || tool; lineStart=null; });
  symSel.addEventListener('change', ()=>{ sym = symSel.value; symOut.textContent = tr().symMap[sym] || sym; });

  rbSw.addEventListener('click', ()=>{ rainbow=!rainbow; setSwitch(rbSw,rainbow); toast(tr().labRainbow, rainbow?'ON':'OFF'); saveAuto(); });
  erSw.addEventListener('click', ()=>{ eraser=!eraser; setSwitch(erSw,eraser); toast(tr().labEraser, eraser?'ON':'OFF'); saveAuto(); });
  glSw.addEventListener('click', ()=>{ showGrid=!showGrid; setSwitch(glSw,showGrid); drawGrid(); toast(tr().labGridLines, showGrid?'ON':'OFF'); saveAuto(); });
  olSw.addEventListener('click', ()=>{ outlineOn=!outlineOn; setSwitch(olSw,outlineOn); outVal.textContent = outlineOn ? tr().on : tr().off; drawAll(); saveAuto(); });
  trSw.addEventListener('click', ()=>{ trailOn=!trailOn; setSwitch(trSw,trailOn); toast(tr().trail, trailOn?'ON':'OFF'); saveAuto(); });

  fpsSlider.addEventListener('input', ()=>{ fps = +fpsSlider.value; fpsVal.textContent = String(fps); saveAuto(); });
  fpsVal.textContent = String(fps);

  onionSw.addEventListener('click', ()=>{ onion=!onion; setSwitch(onionSw,onion); drawAll(); saveAuto(); });
  playSw.addEventListener('click', ()=>{ playing=!playing; setSwitch(playSw,playing); toast(tr().play, playing?'ON':'OFF'); saveAuto(); });

  newBtn.addEventListener('click', newProject);
  undoBtn.addEventListener('click', doUndo);
  redoBtn.addEventListener('click', doRedo);
  clearBtn.addEventListener('click', clearAll);
  saveBtn.addEventListener('click', savePNG);
  exportBtn.addEventListener('click', exportJSON);
  importBtn.addEventListener('click', ()=> fileIn.click());
  restoreBtn.addEventListener('click', ()=> { if(!loadAuto()) toast('Restore', 'Nothing'); });
  wipeAutoBtn.addEventListener('click', wipeAuto);

  addFrameBtn.addEventListener('click', addFrame);
  dupFrameBtn.addEventListener('click', dupFrame);
  delFrameBtn.addEventListener('click', delFrame);

  fileIn.addEventListener('change', ()=>{
    const f = fileIn.files && fileIn.files[0];
    if(f) importJSONFile(f);
    fileIn.value = '';
  });

  // hotkeys
  window.addEventListener('keydown', (e)=>{
    const mod = e.ctrlKey || e.metaKey;
    if(mod && e.key.toLowerCase()==='z'){ e.preventDefault(); doUndo(); }
    if(mod && (e.key.toLowerCase()==='y' || (e.shiftKey && e.key.toLowerCase()==='z'))){ e.preventDefault(); doRedo(); }

    const k = e.key.toLowerCase();
    if(k==='e'){ eraser=!eraser; setSwitch(erSw,eraser); }
    if(k==='r'){ rainbow=!rainbow; setSwitch(rbSw,rainbow); }
    if(k==='g'){ showGrid=!showGrid; setSwitch(glSw,showGrid); drawGrid(); }
    if(k==='o'){ outlineOn=!outlineOn; setSwitch(olSw,outlineOn); outVal.textContent = outlineOn ? tr().on : tr().off; drawAll(); }
    if(k==='t'){ trailOn=!trailOn; setSwitch(trSw,trailOn); }

    // 1..6 tools
    if(e.key==='1'){ tool='draw'; toolSel.value=tool; toolOut.textContent=tr().tools[tool]; lineStart=null; }
    if(e.key==='2'){ tool='picker'; toolSel.value=tool; toolOut.textContent=tr().tools[tool]; lineStart=null; }
    if(e.key==='3'){ tool='fill'; toolSel.value=tool; toolOut.textContent=tr().tools[tool]; lineStart=null; }
    if(e.key==='4'){ tool='line'; toolSel.value=tool; toolOut.textContent=tr().tools[tool]; lineStart=null; }
    if(e.key==='5'){ tool='rect'; toolSel.value=tool; toolOut.textContent=tr().tools[tool]; lineStart=null; }
    if(e.key==='6'){ tool='circle'; toolSel.value=tool; toolOut.textContent=tr().tools[tool]; lineStart=null; }
  });

  // pointer drawing with gap-free interpolation
  function lerpCells(a,b){
    if(!a) return [b];
    const out = [];
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    const steps = Math.max(Math.abs(dx), Math.abs(dy));
    for(let i=1;i<=steps;i++){
      const x = Math.round(a.x + dx*(i/steps));
      const y = Math.round(a.y + dy*(i/steps));
      out.push({x,y});
    }
    return out;
  }

  canvas.addEventListener('contextmenu', (e)=> e.preventDefault());

  canvas.addEventListener('pointerdown', (e) => {
    canvas.setPointerCapture(e.pointerId);

    // RMB temp eraser
    if(e.button === 2){
      rmbTemp = true;
      prevEraser = eraser;
      eraser = true;
      setSwitch(erSw, eraser);
    }

    const {x,y} = posToCell(e);

    if(tool === 'picker'){ pickAtCell(x,y); return; }
    if(tool === 'fill'){ floodFill(x,y); return; }

    // shape tools: two clicks
    if(tool === 'line' || tool === 'rect' || tool === 'circle'){
      if(!lineStart){
        lineStart = {x,y};
        toast('Set', `(${x},${y})`);
        return;
      }
      beginStroke();
      if(tool === 'line') drawLine(lineStart.x, lineStart.y, x, y);
      if(tool === 'rect') drawRect(lineStart.x, lineStart.y, x, y, e.shiftKey);
      if(tool === 'circle'){
        const r = Math.max(1, Math.round(Math.hypot(x-lineStart.x, y-lineStart.y)));
        drawCircle(lineStart.x, lineStart.y, r, e.shiftKey);
      }
      endStroke();
      drawAll();
      lineStart = null;
      return;
    }

    // draw tool
    drawing = true;
    lastCell = null;
    beginStroke();
    for(const c of lerpCells(lastCell,{x,y})){
      paintBrush(c.x,c.y);
    }
    lastCell = {x,y};
  });

  canvas.addEventListener('pointermove', (e) => {
    const {x,y} = posToCell(e);

    // UI: show coords
    const w = parseFloat(uiCanvas.style.width) || 600;
    uctx.save();
    uctx.clearRect(0,0,w,w);
    uctx.globalAlpha = 0.75;
    uctx.fillStyle = 'rgba(0,0,0,.35)';
    uctx.fillRect(10, 10, 132, 28);
    uctx.globalAlpha = 1;
    uctx.fillStyle = 'rgba(245,250,255,.86)';
    uctx.font = '12px ui-monospace, Menlo, Consolas, monospace';
    uctx.fillText(`x:${x} y:${y}`, 18, 29);
    uctx.restore();

    if(!drawing) return;
    const cells = lerpCells(lastCell, {x,y});
    for(const c of cells) paintBrush(c.x,c.y);
    lastCell = {x,y};
  });

  const end = () => {
    if(drawing){
      drawing = false;
      lastCell = null;
      endStroke();
    }
    if(rmbTemp){
      rmbTemp = false;
      eraser = prevEraser;
      setSwitch(erSw, eraser);
    }
  };
  canvas.addEventListener('pointerup', end);
  canvas.addEventListener('pointercancel', end);

  // playback
  function tick(now){
    const dt = (now - lastT) / 1000;
    lastT = now;

    if(playing && frames.length > 1){
      playAcc += dt;
      const spf = 1 / fps;
      while(playAcc >= spf){
        playAcc -= spf;
        fi = (fi + 1) % frames.length;
        rebuildChips();
        drawAll();
      }
    }
    requestAnimationFrame(tick);
  }

  // init
  addRecent(colorPicker.value);
  rebuildChips();
  updateUI();
  setupCanvases();

  let resizeT = 0;
  window.addEventListener('resize', () => {
    clearTimeout(resizeT);
    resizeT = setTimeout(setupCanvases, 120);
  });

  // start FX loops
  requestAnimationFrame(fxTick);
  requestAnimationFrame(uiTick);
  requestAnimationFrame(tick);

  // load autosave silently
  queueMicrotask(()=>{ loadAuto(); });

  toast('Ready', 'Pro');
})();
</script>
</body>
</html>
