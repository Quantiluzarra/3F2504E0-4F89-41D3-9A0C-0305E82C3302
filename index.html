<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Multicolor Square</title>
<style>
  :root{
    --bg:#070a10;
    --panel: rgba(16,20,30,.62);
    --panel2: rgba(10,14,22,.72);
    --line: rgba(255,255,255,.10);
    --text: rgba(245,250,255,.92);
    --muted: rgba(190,205,223,.70);
    --a1:#6E7BFF;
    --a2:#20D2A2;
    --a3:#FF5CAD;
    --shadow: 0 28px 90px rgba(0,0,0,.6);
    --r: 18px;
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    --sans: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;
    --ease: cubic-bezier(.2,.85,.2,1);
  }

  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family: var(--sans);
    color: var(--text);
    background: var(--bg);
    overflow:hidden;
  }

  /* Infinite animated background (fat but clean) */
  body::before{
    content:"";
    position: fixed;
    inset:-20%;
    z-index:-2;
    background:
      radial-gradient(820px 620px at 12% 15%, rgba(110,123,255,.34), transparent 62%),
      radial-gradient(820px 620px at 88% 20%, rgba(32,210,162,.22), transparent 64%),
      radial-gradient(820px 620px at 50% 92%, rgba(255,92,173,.18), transparent 62%),
      linear-gradient(-45deg, rgba(110,123,255,.15), rgba(32,210,162,.10), rgba(255,92,173,.10), rgba(110,123,255,.15));
    background-size: 160% 160%;
    filter: saturate(1.2) contrast(1.06);
    animation: bgMove 12s var(--ease) infinite alternate;
    transform: translateZ(0);
  }
  @keyframes bgMove{
    0%{ background-position: 0% 50%; transform: scale(1.02) rotate(-.15deg); }
    100%{ background-position: 100% 50%; transform: scale(1.06) rotate(.15deg); }
  }

  body::after{
    content:"";
    position: fixed;
    inset:0;
    z-index:-1;
    opacity:.26;
    background-image:
      repeating-linear-gradient( 90deg, rgba(255,255,255,.06) 0 1px, transparent 1px 44px),
      repeating-linear-gradient(180deg, rgba(255,255,255,.05) 0 1px, transparent 1px 44px),
      repeating-linear-gradient(-45deg, rgba(110,123,255,0) 0 18px, rgba(110,123,255,.12) 18px 19px, rgba(110,123,255,0) 19px 38px);
    background-size: 44px 44px, 44px 44px, 160px 160px;
    animation: gridFlow 26s linear infinite;
    mask-image: radial-gradient(circle at 50% 40%, black 0 58%, transparent 80%);
    pointer-events:none;
  }
  @keyframes gridFlow{
    from{ background-position: 0 0, 0 0, 0 0; }
    to{ background-position: -1200px 0, 0 -900px, 700px 300px; }
  }

  @media (prefers-reduced-motion: reduce){
    body::before, body::after{ animation:none !important; }
  }

  /* Layout */
  .app{
    height:100%;
    display:grid;
    grid-template-columns: 340px 1fr;
    gap: 14px;
    padding: 14px;
  }
  @media (max-width: 980px){
    body{ overflow:auto; }
    .app{ grid-template-columns: 1fr; }
  }

  .panel{
    border: 1px solid var(--line);
    border-radius: var(--r);
    background: linear-gradient(180deg, var(--panel), var(--panel2));
    box-shadow: var(--shadow);
    backdrop-filter: blur(14px);
    overflow:hidden;
  }

  .pHead{
    padding: 14px 14px 10px;
    border-bottom: 1px solid rgba(255,255,255,.09);
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
  }
  .brand{
    display:flex; align-items:center; gap:12px;
  }
  .logo{
    width: 36px; height: 36px;
    border-radius: 14px;
    background: conic-gradient(from 180deg, var(--a1), var(--a2), var(--a3), var(--a1));
    box-shadow: 0 0 0 3px rgba(255,255,255,.06), 0 20px 60px rgba(110,123,255,.18);
    position:relative;
    overflow:hidden;
  }
  .logo::after{
    content:"";
    position:absolute; inset:-70%;
    background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.22), transparent 55%);
    animation: sheen 3.0s var(--ease) infinite;
  }
  @keyframes sheen{
    0%{ transform: translate3d(-12%, -10%, 0) rotate(8deg); opacity:.18; }
    50%{ transform: translate3d(12%, 10%, 0) rotate(18deg); opacity:.28; }
    100%{ transform: translate3d(-12%, -10%, 0) rotate(8deg); opacity:.18; }
  }
  @media (prefers-reduced-motion: reduce){ .logo::after{ animation:none !important; } }

  .name{
    margin:0;
    font-size: 14px;
    letter-spacing: 2.6px;
    text-transform: uppercase;
  }
  .mini{
    margin-top: 4px;
    font-family: var(--mono);
    font-size: 12px;
    color: var(--muted);
  }

  .pBody{ padding: 12px 14px 14px; display:grid; gap:10px; }
  .row{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
  .row1{ display:grid; grid-template-columns: 1fr; gap:10px; }

  .field{
    border: 1px solid rgba(255,255,255,.12);
    background: rgba(255,255,255,.04);
    border-radius: 14px;
    padding: 10px;
    display:flex;
    flex-direction:column;
    gap:6px;
  }
  .lab{
    font-family: var(--mono);
    font-size: 12px;
    color: rgba(190,205,223,.70);
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
  }
  input[type="range"]{ width:100%; }
  input[type="color"]{
    width: 100%;
    height: 34px;
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,.14);
    background: transparent;
    padding: 0;
  }
  select, button{
    font-family: inherit;
  }

  .btnRow{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
  }
  .btn{
    border: 1px solid rgba(110,123,255,.45);
    background: rgba(110,123,255,.14);
    color: var(--text);
    padding: 10px 12px;
    border-radius: 14px;
    cursor:pointer;
    font-size: 13px;
    user-select:none;
    position:relative;
    overflow:hidden;
    transition: transform 200ms var(--ease), background 200ms var(--ease), border-color 200ms var(--ease);
  }
  .btn:hover{ transform: translateY(-1px); background: rgba(110,123,255,.20); border-color: rgba(32,210,162,.40); }
  .btn:active{ transform: translateY(0) scale(.99); }
  .btn.ghost{
    border-color: rgba(255,255,255,.14);
    background: rgba(255,255,255,.04);
    color: var(--muted);
  }
  .btn.ghost:hover{ background: rgba(255,255,255,.06); color: var(--text); border-color: rgba(255,255,255,.20); }
  .toggle{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
  }
  .sw{
    width: 44px; height: 26px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,.16);
    background: rgba(255,255,255,.06);
    position:relative;
    cursor:pointer;
    flex: 0 0 auto;
    transition: background 200ms var(--ease);
  }
  .sw i{
    position:absolute; top: 3px; left: 3px;
    width: 20px; height: 20px;
    border-radius: 999px;
    background: rgba(245,250,255,.85);
    box-shadow: 0 12px 24px rgba(0,0,0,.25);
    transition: transform 220ms var(--ease), background 220ms var(--ease);
  }
  .sw.on{ background: rgba(32,210,162,.14); border-color: rgba(32,210,162,.35); }
  .sw.on i{ transform: translateX(18px); background: rgba(32,210,162,.92); }

  .hint{
    font-family: var(--mono);
    font-size: 12px;
    color: rgba(190,205,223,.60);
    padding-top: 4px;
  }

  /* Canvas area */
  .stage{
    border: 1px solid var(--line);
    border-radius: var(--r);
    background: rgba(0,0,0,.16);
    box-shadow: var(--shadow);
    position: relative;
    overflow:hidden;
    min-height: 520px;
  }
  .stageInner{
    position:absolute;
    inset:0;
    display:grid;
    place-items:center;
  }
  .canWrap{
    position: relative;
    transform: translateZ(0);
    will-change: transform;
  }
  canvas{
    display:block;
    border-radius: 14px;
    background: #0b0f17;
    box-shadow: 0 26px 80px rgba(0,0,0,.55);
    touch-action: none; /* important for pointer drawing */
  }
  #gridOverlay{
    position:absolute;
    inset:0;
    pointer-events:none;
    background: transparent;
  }

  .toast{
    position: fixed;
    right: 14px;
    bottom: 14px;
    z-index: 50;
    border: 1px solid rgba(255,255,255,.12);
    border-radius: 16px;
    background: rgba(10,14,22,.78);
    backdrop-filter: blur(12px);
    padding: 10px 12px;
    display:none;
    box-shadow: 0 20px 60px rgba(0,0,0,.45);
    min-width: min(360px, calc(100vw - 28px));
  }
  .toast.show{ display:block; animation: toastIn 220ms var(--ease) both; }
  @keyframes toastIn{
    from{ transform: translateY(10px); opacity: 0; }
    to{ transform: translateY(0); opacity: 1; }
  }
  .toast .t1{ font-size: 13px; }
  .toast .t2{ margin-top: 6px; font-family: var(--mono); font-size: 12px; color: rgba(190,205,223,.70); }

  /* =========================
     ADD-ON: richer background + glow + FX overlay
     ========================= */
  :root{ --mx:.5; --my:.5; }

  .app{ position: relative; }

  .app::before{
    content:"";
    position: fixed;
    inset:-25%;
    z-index:-3;
    background:
      radial-gradient(900px 700px at calc(20% + var(--mx)*20%) calc(15% + var(--my)*18%),
        rgba(110,123,255,.26), transparent 62%),
      radial-gradient(900px 700px at calc(80% - var(--mx)*18%) calc(22% + var(--my)*14%),
        rgba(32,210,162,.18), transparent 64%),
      radial-gradient(900px 700px at calc(50% + var(--mx)*10%) calc(88% - var(--my)*14%),
        rgba(255,92,173,.14), transparent 60%),
      conic-gradient(from 190deg at 50% 50%,
        rgba(110,123,255,.10),
        rgba(32,210,162,.08),
        rgba(255,92,173,.08),
        rgba(110,123,255,.10));
    filter: saturate(1.25) contrast(1.08) blur(.2px);
    animation: auroraDrift 16s var(--ease) infinite alternate;
    transform: translate3d(0,0,0);
    pointer-events:none;
  }
  @keyframes auroraDrift{
    0%{ transform: translate3d(-1.2%, -0.8%, 0) scale(1.02) rotate(-.2deg); }
    100%{ transform: translate3d(1.2%, 0.9%, 0) scale(1.06) rotate(.2deg); }
  }

  .app::after{
    content:"";
    position: fixed;
    inset:0;
    z-index:-1;
    pointer-events:none;
    opacity:.07;
    background-image:
      url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='220' height='220'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='220' height='220' filter='url(%23n)' opacity='.8'/%3E%3C/svg%3E");
    mix-blend-mode: overlay;
    animation: grainShift 6s linear infinite;
  }
  @keyframes grainShift{
    0%{ transform: translate3d(0,0,0); }
    100%{ transform: translate3d(-2%, 1%, 0); }
  }

  .stage.panel{ isolation:isolate; }
  .stage.panel::before{
    content:"";
    position:absolute;
    inset:-2px;
    border-radius: calc(var(--r) + 2px);
    background: conic-gradient(from 210deg,
      rgba(110,123,255,.35),
      rgba(32,210,162,.22),
      rgba(255,92,173,.22),
      rgba(110,123,255,.35));
    filter: blur(14px);
    opacity:.25;
    animation: stageSpin 10s linear infinite;
    z-index:0;
    pointer-events:none;
  }
  @keyframes stageSpin{
    from{ transform: rotate(0deg); }
    to{ transform: rotate(360deg); }
  }
  .stageInner{ position:relative; z-index:1; }

  #fxOverlay{
    position:absolute;
    inset:0;
    pointer-events:none;
    background: transparent;
  }
</style>
</head>

<body>
  <div class="app">
    <!-- Left: settings -->
    <aside class="panel" aria-label="Settings">
      <div class="pHead">
        <div class="brand">
          <div class="logo" aria-hidden="true"></div>
          <div>
            <h1 class="name">MULTICOLOR SQUARE</h1>
            <div class="mini">pixel canvas</div>
          </div>
        </div>
        <button class="btn ghost" id="newBtn" type="button" title="New">New</button>
      </div>

      <div class="pBody">
        <div class="row">
          <div class="field">
            <div class="lab"><span>Grid</span><span id="gridVal">48</span></div>
            <input id="grid" type="range" min="16" max="160" value="48" step="1" />
          </div>
          <div class="field">
            <div class="lab"><span>Brush</span><span id="brushVal">1</span></div>
            <input id="brush" type="range" min="1" max="8" value="1" step="1" />
          </div>
        </div>

        <div class="row">
          <div class="field">
            <div class="lab"><span>Color</span><span id="hexOut">#20D2A2</span></div>
            <input id="color" type="color" value="#20D2A2"/>
          </div>
          <div class="field">
            <div class="lab"><span>Zoom</span><span id="zoomVal">100%</span></div>
            <input id="zoom" type="range" min="60" max="180" value="100" step="1" />
          </div>
        </div>

        <div class="field">
          <div class="toggle">
            <div class="lab" style="margin:0;"><span>Rainbow</span><span id="rbHint"></span></div>
            <div class="sw" id="rb"><i></i></div>
          </div>
          <div class="toggle" style="margin-top:10px;">
            <div class="lab" style="margin:0;"><span>Eraser</span><span></span></div>
            <div class="sw" id="er"><i></i></div>
          </div>
          <div class="toggle" style="margin-top:10px;">
            <div class="lab" style="margin:0;"><span>Grid lines</span><span></span></div>
            <div class="sw on" id="gl"><i></i></div>
          </div>
        </div>

        <div class="btnRow">
          <button class="btn ghost" id="undoBtn" type="button">Undo</button>
          <button class="btn ghost" id="redoBtn" type="button">Redo</button>
          <button class="btn ghost" id="clearBtn" type="button">Clear</button>
          <button class="btn" id="saveBtn" type="button">Save PNG</button>
        </div>

        <div class="btnRow">
          <button class="btn ghost" id="exportBtn" type="button">Export</button>
          <button class="btn ghost" id="importBtn" type="button">Import</button>
          <input id="fileIn" type="file" accept="application/json" style="display:none;">
        </div>

        <!-- =========================
             ADD-ON: tools (no external libs)
             ========================= -->
        <div class="field">
          <div class="lab"><span>Tools</span><span class="mini" style="letter-spacing:0;">I: picker • F: fill • Wheel: zoom</span></div>

          <div class="row1">
            <div class="row">
              <button class="btn ghost" id="pickerBtn" type="button">Eyedropper</button>
              <button class="btn ghost" id="fillBtn" type="button">Fill</button>
            </div>

            <div class="row">
              <div class="field" style="margin:0;">
                <div class="lab"><span>Symmetry</span><span id="symVal">Off</span></div>
                <select id="symSel" style="height:34px;border-radius:12px;border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.04);color:var(--text);padding:0 10px;">
                  <option value="off">Off</option>
                  <option value="h">Horizontal</option>
                  <option value="v">Vertical</option>
                  <option value="hv">4-way</option>
                </select>
              </div>

              <div class="field" style="margin:0;">
                <div class="toggle">
                  <div class="lab" style="margin:0;"><span>Autosave</span><span></span></div>
                  <div class="sw on" id="as"><i></i></div>
                </div>
              </div>
            </div>

            <div class="btnRow">
              <button class="btn ghost" id="restoreBtn" type="button">Restore autosave</button>
              <button class="btn ghost" id="wipeAutoBtn" type="button">Wipe autosave</button>
            </div>

            <div class="hint" style="padding-top:6px;">
              RMB: temporary eraser • Shift+Wheel: faster zoom
            </div>
          </div>
        </div>

        <div class="hint">
          Draw: hold LMB + move • Touch: draw with finger
        </div>
      </div>
    </aside>

    <!-- Right: canvas -->
    <section class="stage panel" aria-label="Canvas">
      <div class="stageInner">
        <div class="canWrap" id="canWrap">
          <canvas id="paint"></canvas>
          <canvas id="gridOverlay"></canvas>
          <!-- ADD-ON -->
          <canvas id="fxOverlay"></canvas>
        </div>
      </div>
    </section>
  </div>

  <div class="toast" id="toast" role="status" aria-live="polite">
    <div class="t1" id="t1">OK</div>
    <div class="t2" id="t2">…</div>
  </div>

<script>
(() => {
  const $ = (s, r=document) => r.querySelector(s);
  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));

  const canvas = $('#paint');
  const ctx = canvas.getContext('2d', { alpha: false });
  const gridCanvas = $('#gridOverlay');
  const gctx = gridCanvas.getContext('2d');

  const gridSlider = $('#grid');
  const brushSlider = $('#brush');
  const zoomSlider = $('#zoom');
  const colorPicker = $('#color');

  const gridVal = $('#gridVal');
  const brushVal = $('#brushVal');
  const zoomVal = $('#zoomVal');
  const hexOut = $('#hexOut');

  const rbSw = $('#rb');
  const erSw = $('#er');
  const glSw = $('#gl');

  const newBtn = $('#newBtn');
  const undoBtn = $('#undoBtn');
  const redoBtn = $('#redoBtn');
  const clearBtn = $('#clearBtn');
  const saveBtn = $('#saveBtn');
  const exportBtn = $('#exportBtn');
  const importBtn = $('#importBtn');
  const fileIn = $('#fileIn');

  const canWrap = $('#canWrap');

  const toastEl = $('#toast');
  const t1 = $('#t1');
  const t2 = $('#t2');
  let toastTimer = 0;
  function toast(a, b=''){
    t1.textContent = a; t2.textContent = b;
    toastEl.classList.add('show');
    clearTimeout(toastTimer);
    toastTimer = setTimeout(()=>toastEl.classList.remove('show'), 2200);
  }

  // state
  let N = +gridSlider.value;           // grid count (NxN)
  let brush = +brushSlider.value;      // brush size in cells
  let zoom = +zoomSlider.value / 100;  // visual zoom
  let showGrid = true;
  let rainbow = false;
  let eraser = false;

  const BG = 0x0b0f17; // background color in RGB (same as canvas CSS)
  let pixels = new Uint32Array(N*N); // store as 0xRRGGBB
  pixels.fill(BG);

  // undo/redo: each action = { idxs:[], prev:[], next:[] }
  const undo = [];
  const redo = [];
  const MAX_STACK = 60;

  // pointer draw
  let drawing = false;
  let lastCell = -1;
  let currentAction = null;

  function hexToRgbInt(hex){
    const s = hex.replace('#','').trim();
    const v = parseInt(s, 16);
    return v & 0xFFFFFF;
  }
  function rgbIntToHex(v){
    return '#' + (v >>> 0).toString(16).padStart(6,'0').toUpperCase();
  }
  function hslToRgbInt(h, s, l){
    // h [0..360), s,l [0..1]
    h = ((h % 360) + 360) % 360;
    const c = (1 - Math.abs(2*l - 1)) * s;
    const x = c * (1 - Math.abs(((h/60) % 2) - 1));
    const m = l - c/2;
    let r=0,g=0,b=0;
    if(h < 60){ r=c; g=x; b=0; }
    else if(h < 120){ r=x; g=c; b=0; }
    else if(h < 180){ r=0; g=c; b=x; }
    else if(h < 240){ r=0; g=x; b=c; }
    else if(h < 300){ r=x; g=0; b=c; }
    else { r=c; g=0; b=x; }
    const R = Math.round((r+m)*255);
    const G = Math.round((g+m)*255);
    const B = Math.round((b+m)*255);
    return (R<<16) | (G<<8) | B;
  }

  function setSwitch(sw, on){
    sw.classList.toggle('on', !!on);
  }

  function updateUI(){
    gridVal.textContent = String(N);
    brushVal.textContent = String(brush);
    zoomVal.textContent = Math.round(zoom*100) + '%';
    hexOut.textContent = colorPicker.value.toUpperCase();
    setSwitch(rbSw, rainbow);
    setSwitch(erSw, eraser);
    setSwitch(glSw, showGrid);
  }

  function calcCanvasSize(){
    const stage = document.querySelector('.stage');
    const r = stage.getBoundingClientRect();
    // keep square, leave padding
    const pad = 26;
    const size = Math.max(280, Math.min(r.width - pad, r.height - pad));
    return Math.floor(size);
  }

  function setupCanvases(){
    const size = calcCanvasSize();
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

    // internal resolution = size*dpr, but we draw cells onto it exactly
    canvas.width = Math.floor(size * dpr);
    canvas.height = Math.floor(size * dpr);
    canvas.style.width = size + 'px';
    canvas.style.height = size + 'px';

    gridCanvas.width = canvas.width;
    gridCanvas.height = canvas.height;
    gridCanvas.style.width = canvas.style.width;
    gridCanvas.style.height = canvas.style.height;

    ctx.setTransform(dpr,0,0,dpr,0,0);
    gctx.setTransform(dpr,0,0,dpr,0,0);

    canWrap.style.transform = `scale(${zoom})`;
    drawAll();
    drawGrid();
  }

  function cellSizePx(){
    // in CSS pixels
    const size = parseFloat(canvas.style.width) || 600;
    return size / N;
  }

  function drawAll(){
    const size = parseFloat(canvas.style.width) || 600;
    const cs = size / N;

    // Fill background fast
    ctx.fillStyle = '#' + BG.toString(16).padStart(6,'0');
    ctx.fillRect(0,0,size,size);

    // Draw cells
    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        const idx = y*N + x;
        const col = pixels[idx];
        if(col === BG) continue;
        ctx.fillStyle = '#' + (col>>>0).toString(16).padStart(6,'0');
        ctx.fillRect(x*cs, y*cs, cs, cs);
      }
    }
  }

  function drawGrid(){
    const size = parseFloat(gridCanvas.style.width) || 600;
    const cs = size / N;

    gctx.clearRect(0,0,size,size);
    if(!showGrid) return;

    gctx.globalAlpha = 0.55;
    gctx.lineWidth = 1;
    gctx.strokeStyle = 'rgba(255,255,255,.10)';

    // avoid heavy grid for huge N: draw every 2 or 4 lines
    let step = 1;
    if(N >= 96) step = 2;
    if(N >= 128) step = 4;

    gctx.beginPath();
    for(let i=0;i<=N;i+=step){
      const p = i*cs;
      gctx.moveTo(p, 0); gctx.lineTo(p, size);
      gctx.moveTo(0, p); gctx.lineTo(size, p);
    }
    gctx.stroke();
    gctx.globalAlpha = 1;
  }

  function paintCell(x, y, col){
    if(x < 0 || y < 0 || x >= N || y >= N) return;
    const idx = y*N + x;

    // record action patch
    const prev = pixels[idx];
    if(prev === col) return;

    // for current stroke: store each idx once
    if(currentAction){
      if(!currentAction.seen.has(idx)){
        currentAction.seen.add(idx);
        currentAction.idxs.push(idx);
        currentAction.prev.push(prev);
        currentAction.next.push(col);
      }
    }

    pixels[idx] = col;

    // draw only this cell
    const size = parseFloat(canvas.style.width) || 600;
    const cs = size / N;
    ctx.fillStyle = '#' + (col>>>0).toString(16).padStart(6,'0');
    ctx.fillRect(x*cs, y*cs, cs, cs);
  }

  function paintBrush(cx, cy){
    const half = Math.floor(brush / 2);
    const base = eraser ? BG : hexToRgbInt(colorPicker.value);
    const t = performance.now() * 0.001;

    for(let dy=-half; dy< -half+brush; dy++){
      for(let dx=-half; dx< -half+brush; dx++){
        const x = cx + dx;
        const y = cy + dy;

        let col = base;
        if(rainbow && !eraser){
          const hue = (t*90 + (x*9) + (y*7)) % 360;
          col = hslToRgbInt(hue, 1.0, 0.55);
        }
        paintCell(x, y, col);
      }
    }
  }

  function posToCell(e){
    const rect = canvas.getBoundingClientRect();
    const size = rect.width; // CSS px
    const cs = size / N;
    const x = Math.floor((e.clientX - rect.left) / cs);
    const y = Math.floor((e.clientY - rect.top) / cs);
    return { x, y };
  }

  function beginStroke(){
    currentAction = { idxs:[], prev:[], next:[], seen: new Set() };
  }
  function endStroke(){
    if(!currentAction) return;
    if(currentAction.idxs.length){
      // push to undo stack
      undo.push({
        idxs: currentAction.idxs,
        prev: currentAction.prev,
        next: currentAction.next
      });
      if(undo.length > MAX_STACK) undo.shift();
      redo.length = 0;
    }
    currentAction = null;
  }

  function doUndo(){
    const a = undo.pop();
    if(!a) return;
    for(let i=0;i<a.idxs.length;i++){
      pixels[a.idxs[i]] = a.prev[i];
    }
    redo.push(a);
    drawAll();
    toast('Undo', `${a.idxs.length} cells`);
  }
  function doRedo(){
    const a = redo.pop();
    if(!a) return;
    for(let i=0;i<a.idxs.length;i++){
      pixels[a.idxs[i]] = a.next[i];
    }
    undo.push(a);
    drawAll();
    toast('Redo', `${a.idxs.length} cells`);
  }

  function clearAll(){
    const prev = Array.from(pixels);
    pixels.fill(BG);
    drawAll();
    undo.push({
      idxs: prev.map((_,i)=>i),
      prev: prev,
      next: Array(prev.length).fill(BG)
    });
    if(undo.length > MAX_STACK) undo.shift();
    redo.length = 0;
    toast('Clear', 'Canvas reset');
  }

  function newCanvas(){
    // reset stacks and pixels
    undo.length = 0; redo.length = 0;
    pixels = new Uint32Array(N*N);
    pixels.fill(BG);
    drawAll();
    drawGrid();
    toast('New', `${N}×${N}`);
  }

  function savePNG(){
    // render to offscreen at higher resolution: each cell = 20px (nice)
    const cellPx = 20;
    const outSize = N * cellPx;
    const off = document.createElement('canvas');
    off.width = outSize;
    off.height = outSize;
    const o = off.getContext('2d', { alpha: false });

    // background
    o.fillStyle = '#' + BG.toString(16).padStart(6,'0');
    o.fillRect(0,0,outSize,outSize);

    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        const idx = y*N + x;
        const col = pixels[idx];
        if(col === BG) continue;
        o.fillStyle = '#' + (col>>>0).toString(16).padStart(6,'0');
        o.fillRect(x*cellPx, y*cellPx, cellPx, cellPx);
      }
    }

    const url = off.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = url;
    a.download = `multicolor-square_${N}x${N}.png`;
    a.click();
    toast('Saved', a.download);
  }

  function exportJSON(){
    const payload = {
      app: 'Multicolor Square',
      v: 1,
      N,
      BG,
      pixels: Array.from(pixels) // simple + portable
    };
    const blob = new Blob([JSON.stringify(payload)], { type:'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `multicolor-square_${N}x${N}.json`;
    a.click();
    URL.revokeObjectURL(url);
    toast('Export', a.download);
  }

  async function importJSONFile(file){
    try{
      const text = await file.text();
      const data = JSON.parse(text);
      if(!data || data.app !== 'Multicolor Square' || !Number.isFinite(data.N) || !Array.isArray(data.pixels)){
        toast('Import', 'Invalid file');
        return;
      }
      N = clamp(data.N|0, 16, 160);
      gridSlider.value = String(N);
      pixels = new Uint32Array(N*N);
      const arr = data.pixels;
      for(let i=0;i<pixels.length;i++){
        pixels[i] = (arr[i] >>> 0) & 0xFFFFFF;
      }
      undo.length = 0; redo.length = 0;
      updateUI();
      setupCanvases();
      toast('Import', `${N}×${N}`);
    }catch(e){
      toast('Import', 'Error');
    }
  }

  // pointer events for draw
  canvas.addEventListener('pointerdown', (e) => {
    canvas.setPointerCapture(e.pointerId);
    drawing = true;
    lastCell = -1;
    beginStroke();
    const {x,y} = posToCell(e);
    const cell = y*N + x;
    lastCell = cell;
    paintBrush(x,y);
  });

  canvas.addEventListener('pointermove', (e) => {
    if(!drawing) return;
    const {x,y} = posToCell(e);
    const cell = y*N + x;
    if(cell === lastCell) return;
    lastCell = cell;
    paintBrush(x,y);
  });

  const end = () => {
    if(!drawing) return;
    drawing = false;
    lastCell = -1;
    endStroke();
  };
  canvas.addEventListener('pointerup', end);
  canvas.addEventListener('pointercancel', end);
  canvas.addEventListener('pointerleave', (e) => { /* keep drawing if captured */ });

  // Controls
  gridSlider.addEventListener('input', () => {
    N = +gridSlider.value;
    updateUI();
  });
  gridSlider.addEventListener('change', () => {
    // resizing grid wipes canvas (kept minimal)
    newCanvas();
    setupCanvases();
  });

  brushSlider.addEventListener('input', () => {
    brush = +brushSlider.value;
    updateUI();
  });

  zoomSlider.addEventListener('input', () => {
    zoom = +zoomSlider.value / 100;
    updateUI();
    canWrap.style.transform = `scale(${zoom})`;
  });

  colorPicker.addEventListener('input', () => {
    hexOut.textContent = colorPicker.value.toUpperCase();
    if(eraser){
      eraser = false;
      setSwitch(erSw, eraser);
    }
  });

  rbSw.addEventListener('click', () => {
    rainbow = !rainbow;
    setSwitch(rbSw, rainbow);
    toast('Rainbow', rainbow ? 'ON' : 'OFF');
  });

  erSw.addEventListener('click', () => {
    eraser = !eraser;
    setSwitch(erSw, eraser);
    toast('Eraser', eraser ? 'ON' : 'OFF');
  });

  glSw.addEventListener('click', () => {
    showGrid = !showGrid;
    setSwitch(glSw, showGrid);
    drawGrid();
    toast('Grid lines', showGrid ? 'ON' : 'OFF');
  });

  newBtn.addEventListener('click', () => {
    if(confirm('New canvas?')) newCanvas();
  });

  undoBtn.addEventListener('click', doUndo);
  redoBtn.addEventListener('click', doRedo);
  clearBtn.addEventListener('click', () => { if(confirm('Clear?')) clearAll(); });
  saveBtn.addEventListener('click', savePNG);

  exportBtn.addEventListener('click', exportJSON);
  importBtn.addEventListener('click', () => fileIn.click());
  fileIn.addEventListener('change', () => {
    const f = fileIn.files && fileIn.files[0];
    if(f) importJSONFile(f);
    fileIn.value = '';
  });

  // Hotkeys (minimal)
  window.addEventListener('keydown', (e) => {
    const mod = e.ctrlKey || e.metaKey;
    if(mod && e.key.toLowerCase() === 'z'){ e.preventDefault(); doUndo(); }
    if(mod && (e.key.toLowerCase() === 'y' || (e.shiftKey && e.key.toLowerCase() === 'z'))){ e.preventDefault(); doRedo(); }
    if(e.key.toLowerCase() === 'e'){ eraser = !eraser; setSwitch(erSw, eraser); }
    if(e.key.toLowerCase() === 'r'){ rainbow = !rainbow; setSwitch(rbSw, rainbow); }
  });

  // Init
  updateUI();
  setupCanvases();

  let resizeT = 0;
  window.addEventListener('resize', () => {
    clearTimeout(resizeT);
    resizeT = setTimeout(setupCanvases, 120);
  });

  toast('Ready', 'Draw with LMB');

  /* =========================
     ADD-ON: tools + FX + autosave (single file, no libs)
     ========================= */

  // UI (added)
  const pickerBtn = document.getElementById('pickerBtn');
  const fillBtn   = document.getElementById('fillBtn');
  const symSel    = document.getElementById('symSel');
  const symVal    = document.getElementById('symVal');
  const asSw      = document.getElementById('as');
  const restoreBtn= document.getElementById('restoreBtn');
  const wipeAutoBtn = document.getElementById('wipeAutoBtn');

  // FX overlay
  const fxCanvas = document.getElementById('fxOverlay');
  const fctx = fxCanvas.getContext('2d');

  // tool state
  let tool = 'draw';     // draw | picker | fill
  let sym  = 'off';      // off | h | v | hv
  let autosave = true;

  // RMB temp eraser
  let rmbTemp = false;
  let prevEraser = false;

  const LS_KEY = 'multicolor_square_autosave_v1';

  function setTool(t){
    tool = t;
    toast('Tool', t);
  }
  function setSym(v){
    sym = v;
    symVal.textContent =
      v === 'off' ? 'Off' :
      v === 'h'   ? 'H' :
      v === 'v'   ? 'V' : '4-way';
    toast('Symmetry', symVal.textContent);
  }
  function setAutosave(on){
    autosave = !!on;
    setSwitch(asSw, autosave);
    toast('Autosave', autosave ? 'ON' : 'OFF');
    if(autosave) saveAuto();
  }

  // prevent context menu on canvas (so RMB is usable)
  canvas.addEventListener('contextmenu', (e)=> e.preventDefault());

  // background parallax variables
  window.addEventListener('pointermove', (e) => {
    const x = e.clientX / Math.max(1, window.innerWidth);
    const y = e.clientY / Math.max(1, window.innerHeight);
    document.documentElement.style.setProperty('--mx', String(x.toFixed(4)));
    document.documentElement.style.setProperty('--my', String(y.toFixed(4)));
  });

  // Zoom by wheel over stage/canvas
  const stageEl = document.querySelector('.stage');
  stageEl.addEventListener('wheel', (e) => {
    e.preventDefault();
    const fast = e.shiftKey ? 6 : 2;
    const dir = Math.sign(e.deltaY);
    const next = clamp(+zoomSlider.value + (-dir * fast), +zoomSlider.min, +zoomSlider.max);
    zoomSlider.value = String(next);
    zoomSlider.dispatchEvent(new Event('input', { bubbles:true }));
  }, { passive:false });

  // FX sizing
  function fxResizeLikeMain(){
    fxCanvas.width  = gridCanvas.width;
    fxCanvas.height = gridCanvas.height;
    fxCanvas.style.width  = gridCanvas.style.width;
    fxCanvas.style.height = gridCanvas.style.height;

    const cssW = parseFloat(fxCanvas.style.width) || 600;
    const scale = fxCanvas.width / cssW; // ~dpr
    fctx.setTransform(scale,0,0,scale,0,0);
  }

  // patch setupCanvases without touching original body
  const _setupCanvases = setupCanvases;
  setupCanvases = function(){
    _setupCanvases();
    fxResizeLikeMain();
  };

  // eyedropper from pixels[]
  function pickAtCell(x,y){
    if(x<0||y<0||x>=N||y>=N) return;
    const idx = y*N + x;
    const col = pixels[idx] >>> 0;
    if(col === (BG>>>0)) return;
    const hex = rgbIntToHex(col);
    colorPicker.value = hex;
    hexOut.textContent = hex.toUpperCase();
    if(eraser){
      eraser = false;
      setSwitch(erSw, eraser);
    }
    toast('Picked', hex.toUpperCase());
  }

  // flood fill (bucket)
  function floodFill(x,y){
    if(x<0||y<0||x>=N||y>=N) return;
    const target = pixels[y*N+x]>>>0;
    const replacement = eraser ? (BG>>>0) : hexToRgbInt(colorPicker.value);
    if(target === replacement) return;

    beginStroke(); // record undo as one action
    const stack = [x,y];
    const seen = new Uint8Array(N*N);

    while(stack.length){
      const cy = stack.pop();
      const cx = stack.pop();
      if(cx<0||cy<0||cx>=N||cy>=N) continue;
      const idx = cy*N + cx;
      if(seen[idx]) continue;
      seen[idx] = 1;
      if((pixels[idx]>>>0) !== target) continue;

      paintCell(cx, cy, replacement);

      stack.push(cx+1, cy);
      stack.push(cx-1, cy);
      stack.push(cx, cy+1);
      stack.push(cx, cy-1);
    }
    endStroke();
    drawAll();
    toast('Fill', 'Done');
  }

  // Symmetry wrapper for paintBrush
  const _paintBrush = paintBrush;
  paintBrush = function(cx, cy){
    const pts = [[cx,cy]];
    const mx = (N - 1) - cx;
    const my = (N - 1) - cy;

    if(sym === 'h' || sym === 'hv') pts.push([mx, cy]);
    if(sym === 'v' || sym === 'hv') pts.push([cx, my]);
    if(sym === 'hv') pts.push([mx, my]);

    const uniq = new Set();
    for(const [x,y] of pts){
      const k = x + ',' + y;
      if(uniq.has(k)) continue;
      uniq.add(k);
      _paintBrush(x,y);
      fxBurst(x,y);
    }
  };

  // particles FX
  const particles = [];
  function fxBurst(x,y){
    const sizeCss = parseFloat(gridCanvas.style.width) || 600;
    const cs = sizeCss / N;
    const cx = (x + 0.5) * cs;
    const cy = (y + 0.5) * cs;

    const base = eraser ? '#7A88A3' : colorPicker.value;
    for(let i=0;i<6;i++){
      particles.push({
        x: cx, y: cy,
        vx: (Math.random()-.5)*1.4,
        vy: (Math.random()-.5)*1.4,
        life: 1,
        r: 2 + Math.random()*3,
        c: base
      });
    }
  }

  function fxTick(){
    const w = parseFloat(fxCanvas.style.width) || 600;
    const h = w;

    // clear in CSS coord system (transform already matches dpr)
    fctx.clearRect(0,0,w,h);

    fctx.globalCompositeOperation = 'lighter';

    for(let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.life *= 0.885;
      p.x += p.vx;
      p.y += p.vy;
      p.vx *= 0.92;
      p.vy *= 0.92;

      if(p.life < 0.05){ particles.splice(i,1); continue; }

      fctx.globalAlpha = Math.min(0.55, p.life);
      fctx.fillStyle = p.c;
      fctx.beginPath();
      fctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      fctx.fill();
    }

    fctx.globalAlpha = 1;
    fctx.globalCompositeOperation = 'source-over';
    requestAnimationFrame(fxTick);
  }
  requestAnimationFrame(fxTick);

  // autosave (built-in localStorage)
  function makePayload(){
    return { app:'Multicolor Square', v:1, N, BG, pixels: Array.from(pixels) };
  }
  function saveAuto(){
    if(!autosave) return;
    try{
      localStorage.setItem(LS_KEY, JSON.stringify(makePayload()));
    }catch(e){}
  }
  function loadAuto(){
    try{
      const t = localStorage.getItem(LS_KEY);
      if(!t) return false;
      const data = JSON.parse(t);
      if(!data || data.app !== 'Multicolor Square' || !Number.isFinite(data.N) || !Array.isArray(data.pixels)) return false;

      N = clamp(data.N|0, 16, 160);
      gridSlider.value = String(N);

      pixels = new Uint32Array(N*N);
      for(let i=0;i<pixels.length;i++){
        pixels[i] = (data.pixels[i] >>> 0) & 0xFFFFFF;
      }
      undo.length = 0; redo.length = 0;
      updateUI();
      setupCanvases();
      toast('Restored', `${N}×${N}`);
      return true;
    }catch(e){
      return false;
    }
  }
  function wipeAuto(){
    try{
      localStorage.removeItem(LS_KEY);
      toast('Autosave', 'Removed');
    }catch(e){
      toast('Autosave', 'Error');
    }
  }

  // patch endStroke -> autosave after any stroke
  const _endStroke = endStroke;
  endStroke = function(){
    _endStroke();
    saveAuto();
  };

  // tool buttons
  pickerBtn.addEventListener('click', ()=> setTool(tool === 'picker' ? 'draw' : 'picker'));
  fillBtn.addEventListener('click',   ()=> setTool(tool === 'fill'   ? 'draw' : 'fill'));

  symSel.addEventListener('change', ()=> setSym(symSel.value));
  setSym(symSel.value);

  asSw.addEventListener('click', ()=> setAutosave(!autosave));
  setAutosave(true);

  restoreBtn.addEventListener('click', ()=> { if(!loadAuto()) toast('Restore', 'Nothing saved'); });
  wipeAutoBtn.addEventListener('click', wipeAuto);

  // hotkeys
  window.addEventListener('keydown', (e) => {
    if(e.key.toLowerCase() === 'i') setTool(tool === 'picker' ? 'draw' : 'picker');
    if(e.key.toLowerCase() === 'f') setTool(tool === 'fill' ? 'draw' : 'fill');
  });

  // Intercept pointerdown for picker/fill + RMB temp eraser (capture phase)
  canvas.addEventListener('pointerdown', (e) => {
    // RMB temp eraser
    if(e.button === 2){
      rmbTemp = true;
      prevEraser = eraser;
      eraser = true;
      setSwitch(erSw, eraser);
      toast('Eraser', 'RMB temp');
    }

    if(tool === 'draw') return;

    e.preventDefault();
    e.stopPropagation();

    const {x,y} = posToCell(e);
    if(tool === 'picker') pickAtCell(x,y);
    if(tool === 'fill') floodFill(x,y);
  }, true);

  // Restore eraser after RMB stroke ends
  canvas.addEventListener('pointerup', () => {
    if(!rmbTemp) return;
    rmbTemp = false;
    eraser = prevEraser;
    setSwitch(erSw, eraser);
  }, true);
  canvas.addEventListener('pointercancel', () => {
    if(!rmbTemp) return;
    rmbTemp = false;
    eraser = prevEraser;
    setSwitch(erSw, eraser);
  }, true);

  // Re-run setup once so FX canvas is sized immediately
  setupCanvases();

  // Try restore on start (silent)
  queueMicrotask(()=>{ loadAuto(); });

})();
</script>
</body>
</html>
